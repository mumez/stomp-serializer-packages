<?xml version="1.0"?><st-source><!-- Name: StOMP-RuntimeNotice: Copyright (C) 2011- Masashi UmezawaBundleName: StOMP-RuntimeBundleStructure: a Store.BundleForParcelComment: ** StOMP - Smalltalk Objects on MessagePack**http://stomp.smalltalk-users.jp/Yet another multi-dialect object serializer built on MessagePack.The aim is to provide portable, fast, compact serializer for major Smalltalk dialects. StOMP is optimized for small/medium sized data. It is especially suitable for KVS or RPC.This bundle includes minimal set for using StOMP.Prerequisites: MessagePack-Runtime (Bundle)Copyright (C) 2011- Masashi UmezawaDevelopmentPrerequisites: #(#(#any 'UUID' '') #(#any 'MessagePack-Runtime' ''))DisregardedPrerequisites: #()Parcel: #('StOMP-Runtime')ParcelName: StOMP-RuntimePrerequisiteDescriptions: #(#(#name 'UUID' #componentType #package) #(#name 'MessagePack-Runtime' #componentType #bundle))PrerequisiteParcels: #(#('UUID' '') #('MessagePack-Runtime' ''))Version: 1.8.7Date: 9:38:12 PM December 29, 2011 --><time-stamp>From VisualWorks® NonCommercial, 7.7.1 of 2010年7月26日 on 2011年12月29日 at 21:38:12</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StompPopularClassMap</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classToCode codeToClass </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompVwPopularClassMap</name><environment>Smalltalk</environment><super>StompPopularClassMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Squeak-Core</category><attributes><package>Stomp-VW-Core</package></attributes></class><class><name>StompSettings</name><environment>Smalltalk</environment><super>MpSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompWriter</name><environment>Smalltalk</environment><super>MpEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompVwPortableUtil</name><environment>Smalltalk</environment><super>StompPortableUtil</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Squeak-Core</category><attributes><package>Stomp-VW-Core</package></attributes></class><class><name>StompShapeChanger</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompBlockShapeChanger</name><environment>Smalltalk</environment><super>StompShapeChanger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadInstVarsBlock loadAdditionsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompConstants</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>tupleTags </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompWarning</name><environment>Smalltalk</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className element context </inst-vars><class-inst-vars>suppressTranscriptLogging suppressSignaling </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompClassNotFound</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestor objectsDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompWriteContext</name><environment>Smalltalk</environment><super>StompContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classesDictionary environmentsDictionary instVarNamesWithIndicesDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompInvalidDeserialization</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompReadContext</name><environment>Smalltalk</environment><super>StompContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classIdsDictionary environmentNamesDictionary instVarNamesWithIndicesDictionary classAliasesDictionary shapeChangersDictionary fieldsInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompInvalidSerialization</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompFieldsInfo</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type indexFieldSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompReader</name><environment>Smalltalk</environment><super>MpDecoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompNewFailed</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><shared-variable><name>Default</name><environment>StompPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Stomp-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>StompPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Stomp-Core</package></attributes></shared-variable><methods><class-id>StompPopularClassMap</class-id> <category>factory</category><body package="Stomp-Core" selector="associationClass">associationClass	^ self classNamed: #Association</body><body package="Stomp-Core" selector="bagClass">bagClass	^ self classNamed: #Bag</body><body package="Stomp-Core" selector="byteStringClass">byteStringClass	^ self classNamed: #ByteString</body><body package="Stomp-Core" selector="byteSymbolClass">byteSymbolClass	^ self classNamed: #ByteSymbol</body><body package="Stomp-Core" selector="characterClass">characterClass	^ self classNamed: #Character</body><body package="Stomp-Core" selector="colorClass">colorClass	^ self classNamed: #Color</body><body package="Stomp-Core" selector="compactDictionaryClass">compactDictionaryClass	^ self classNamed: #CompactDictionary</body><body package="Stomp-Core" selector="compiledMethodClass">compiledMethodClass	^ self classNamed: #CompiledMethod</body><body package="Stomp-Core" selector="dateAndTimeClass">dateAndTimeClass	^ self classNamed: #DateAndTime</body><body package="Stomp-Core" selector="dateClass">dateClass	^ self classNamed: #Date</body><body package="Stomp-Core" selector="durationClass">durationClass	^ self classNamed: #Duration</body><body package="Stomp-Core" selector="fixedPointClass">fixedPointClass	^ self classNamed: #FixedPoint</body><body package="Stomp-Core" selector="fractionClass">fractionClass	^ self classNamed: #Fraction</body><body package="Stomp-Core" selector="identityDictionaryClass">identityDictionaryClass	^ self classNamed: #IdentityDictionary</body><body package="Stomp-Core" selector="identitySetClass">identitySetClass	^ self classNamed: #IdentitySet</body><body package="Stomp-Core" selector="intervalClass">intervalClass	^ self classNamed: #Interval</body><body package="Stomp-Core" selector="matrixClass">matrixClass	^ self classNamed: #Matrix</body><body package="Stomp-Core" selector="orderedCollectionClass">orderedCollectionClass	^ self classNamed: #OrderedCollection</body><body package="Stomp-Core" selector="orderedSetClass">orderedSetClass	^ self classNamed: #OrderedSet</body><body package="Stomp-Core" selector="pointClass">pointClass	^ self classNamed: #Point</body><body package="Stomp-Core" selector="rectangleClass">rectangleClass	^ self classNamed: #Rectangle</body><body package="Stomp-Core" selector="runArrayClass">runArrayClass	^ self classNamed: #RunArray</body><body package="Stomp-Core" selector="setClass">setClass	^ self classNamed: #Set</body><body package="Stomp-Core" selector="sortedCollectionClass">sortedCollectionClass	^ self classNamed: #SortedCollection</body><body package="Stomp-Core" selector="timeClass">timeClass	^ self classNamed: #Time</body><body package="Stomp-Core" selector="timestampClass">timestampClass	^ self classNamed: #Timestamp</body><body package="Stomp-Core" selector="uint16ArrayClass">uint16ArrayClass	^ self classNamed: #WordArray</body><body package="Stomp-Core" selector="uint32ArrayClass">uint32ArrayClass	^ self classNamed: #DwordArray</body><body package="Stomp-Core" selector="uuidClass">uuidClass	^ self classNamed: #UUID</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>constants</category><body package="Stomp-Core" selector="popularClassSelectors">popularClassSelectors	"Reserved popular classes - if you extend class map, the array should only be appended."	"^(self class organization listAtCategoryNamed: #factory) asSortedCollection."		^ #(#bagClass #compactDictionaryClass #characterClass #colorClass #dateAndTimeClass #dateClass #fractionClass #identityDictionaryClass #identitySetClass #intervalClass #orderedCollectionClass #pointClass #rectangleClass #setClass #sortedCollectionClass #matrixClass #durationClass #timeClass #timestampClass #runArrayClass #orderedSetClass #uuidClass #fixedPointClass #associationClass #compiledMethodClass #uint16ArrayClass #uint32ArrayClass).</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>accessing</category><body package="Stomp-Core" selector="classToCode">classToCode	"Answer the value of classToCode"	^ classToCode</body><body package="Stomp-Core" selector="classToCode:">classToCode: anObject	"Set the value of classToCode"	classToCode := anObject</body><body package="Stomp-Core" selector="codeToClass">codeToClass	"Answer the value of codeToClass"	^ codeToClass</body><body package="Stomp-Core" selector="codeToClass:">codeToClass: anObject	"Set the value of codeToClass"	codeToClass := anObject</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>private</category><body package="Stomp-Core" selector="classNamed:">classNamed: localClassName	^Smalltalk at: localClassName ifAbsent: []</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>actions</category><body package="Stomp-Core" selector="classAt:">classAt: code 	^self codeToClass at: code ifAbsent: [].	</body><body package="Stomp-Core" selector="codeAt:ifPresent:">codeAt: aClass ifPresent: aBlock	| code |	code := self classToCode at: aClass ifAbsent: [].	code == nil ifFalse: [aBlock value: code]</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="initialize">initialize	classToCode := IdentityDictionary new.	codeToClass := IdentityDictionary new.	self prepareMaps</body><body package="Stomp-Core" selector="prepareMaps">prepareMaps		self prepareCodeToClassMap: self codeToClass.	self prepareClassToCodeMap: self classToCode.</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>preparing</category><body package="Stomp-Core" selector="prepareClassToCodeMap:">prepareClassToCodeMap: classToCodeMap	"By default, just create counter-map"	self codeToClass keysAndValuesDo: [:key :value |		classToCodeMap at: value put: key	]</body><body package="Stomp-Core" selector="prepareCodeToClassMap:">prepareCodeToClassMap: codeToClassMap	| selectors |	selectors := self popularClassSelectors.	1 to: selectors size do: [:idx | | kls |		kls := self perform: (selectors at: idx).		kls ifNotNil: [codeToClassMap at: idx put: kls].		]</body></methods><methods><class-id>StompPopularClassMap class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	"self initialize"	self class = StompPopularClassMap ifTrue: [^self initializeAll].	default := nil	</body><body package="Stomp-Core" selector="initializeAll">initializeAll	"self initializeAll"	self allSubclasses do: [:each | each initialize]</body></methods><methods><class-id>StompPopularClassMap class</class-id> <category>accessing</category><body package="Stomp-Core" selector="default">default	"Answer the value of default"	^ default ifNil: [default := super new initialize]</body></methods><methods><class-id>StompVwPopularClassMap</class-id> <category>factory</category><body package="Stomp-VW-Core" selector="colorClass">colorClass	^ self classNamed: #ColorValue</body><body package="Stomp-VW-Core" selector="fixedPointClass">fixedPointClass	^ self classNamed: #ScaledDecimal</body><body package="Stomp-VW-Core" selector="matrixClass">matrixClass	^ self classNamed: #TwoDList</body></methods><methods><class-id>StompSettings</class-id> <category>accessing</category><body package="Stomp-Core" selector="supportsMultibyteIdentifiers">supportsMultibyteIdentifiers	^self at: #supportsMultibyteIdentifiers ifAbsentPut: [false]</body><body package="Stomp-Core" selector="supportsMultibyteIdentifiers:">supportsMultibyteIdentifiers: aBoolean	^self at: #supportsMultibyteIdentifiers put: aBoolean</body><body package="Stomp-Core" selector="suppressNilWrite">suppressNilWrite	^ self writeVariableDefinitionsAsReference not</body><body package="Stomp-Core" selector="suppressNilWrite:">suppressNilWrite: aBoolean		^self writeVariableDefinitionsAsReference: (aBoolean==true) not</body><body package="Stomp-Core" selector="useEnvironment">useEnvironment	^self at: #useEnvironment ifAbsentPut: [StompPortableUtil default useEnvironmentByDefault]</body><body package="Stomp-Core" selector="useEnvironment:">useEnvironment: aBoolean	^self at: #useEnvironment put: aBoolean</body><body package="Stomp-Core" selector="withHeader">withHeader	^self at: #withHeader ifAbsentPut: [false]</body><body package="Stomp-Core" selector="withHeader:">withHeader: aBoolean	^self at: #withHeader put: aBoolean</body><body package="Stomp-Core" selector="writeVariableDefinitionsAsReference">writeVariableDefinitionsAsReference	^self at: #writeVariableDefinitionsAsReference ifAbsentPut: [true]</body><body package="Stomp-Core" selector="writeVariableDefinitionsAsReference:">writeVariableDefinitionsAsReference: aBoolean	^self at: #writeVariableDefinitionsAsReference put: aBoolean</body></methods><methods><class-id>StompWriter</class-id> <category>private</category><body package="Stomp-Core" selector="bytesFromIdentifierString:">bytesFromIdentifierString: aString 	"Usually class &amp; variable names are single bytes"	^ self settings supportsMultibyteIdentifiers		ifTrue: [self portableUtil bytesFromString: aString]		ifFalse: [aString asByteArray]</body><body package="Stomp-Core" selector="rememberReferenceOf:">rememberReferenceOf: originalObject	^ self context rememberReferenceOf: originalObject</body></methods><methods><class-id>StompWriter</class-id> <category>dispatching</category><body package="Stomp-Core" selector="writeObject:">writeObject: anObject	"Main dispatching method"	| writeObject |	anObject stompPrepareWrite.	(self supportsReferenceFor: anObject) ifTrue: [			self putReferenceOf: anObject ifExists: [:refId | ^self writeReference: refId].	].	writeObject := anObject stompWriteValue.		self writeValue: writeObject.	anObject stompAfterWrite	</body><body package="Stomp-Core" selector="writeStompFrom:">writeStompFrom: anObject 	(self settings withHeader and: [self writeStream position = 0])		ifTrue: [self writeVersion].	self writeObject: anObject</body></methods><methods><class-id>StompWriter</class-id> <category>factory</category><body package="Stomp-Core" selector="settingsClass">settingsClass	^StompSettings</body></methods><methods><class-id>StompWriter</class-id> <category>writing</category><body package="Stomp-Core" selector="writeByteString:">writeByteString: aString	self writeArraySize: 2.	self writeTag: StompConstants byteString.	self writeRawBytes: (self portableUtil bytesFromByteString: aString)</body><body package="Stomp-Core" selector="writeByteSymbol:">writeByteSymbol: aSymbol	self writeArraySize: 2.	self writeTag: StompConstants byteSymbol.	self writeRawBytes: aSymbol asByteArray</body><body package="Stomp-Core" selector="writeEmbeddedValue:ifNotApplied:">writeEmbeddedValue: writeObject ifNotApplied: aBlock	writeObject isSymbol ifTrue: [^self writeSymbol: writeObject].	writeObject isString ifTrue: [^self writeString: writeObject].	^ aBlock value</body><body package="Stomp-Core" selector="writeReference:">writeReference: refId	self writeArraySize: 2.	self writeTag: StompConstants reference.	self writeInteger: refId</body><body package="Stomp-Core" selector="writeStandardValue:">writeStandardValue: writeObject 	| sz writeObjectClass classId attributes |	sz := 2 + writeObject stompValueContentSize. 	self writeArraySize: sz.	self writeTag: StompConstants value.	writeObjectClass := writeObject class.	self portableUtil popularClassMap codeAt: writeObjectClass ifPresent: [:code | 		self writeInteger: code negated.		^ self writeContent: writeObject.	].	classId := self context classIdOf: writeObjectClass ifAbsent: [].	classId == nil ifFalse: [		self writeInteger: classId. 		^ self writeContent: writeObject	].	attributes := OrderedCollection new.	self addClassSpecifierAttributesTo: attributes for: writeObject.	self writeMapSize: attributes size.	attributes do: [:assoc |		self writePositiveFixNum: assoc key.		super writeObject: assoc value	].	self writeContent: writeObject</body><body package="Stomp-Core" selector="writeString:">writeString: aString	(self portableUtil isWideString: aString) ifTrue: [^self writeWideString: aString].	self writeByteString: aString</body><body package="Stomp-Core" selector="writeSymbol:">writeSymbol: aSymbol	(self portableUtil isWideSymbol: aSymbol) ifTrue: [^self writeWideSymbol: aSymbol].	self writeByteSymbol: aSymbol</body><body package="Stomp-Core" selector="writeValue:">writeValue: writeObject 	^ self		writeEmbeddedValue: writeObject		ifNotApplied: [self				writeObject: writeObject				ifNotApplied: [self writeStandardValue: writeObject]]</body><body package="Stomp-Core" selector="writeWideString:">writeWideString: aString	self writeArraySize: 2.	self writeTag: StompConstants wideString.	self writeRawBytes: (self portableUtil bytesFromString: aString)</body><body package="Stomp-Core" selector="writeWideSymbol:">writeWideSymbol: aSymbol	self writeArraySize: 2.	self writeTag: StompConstants wideSymbol.	self writeRawBytes: (self portableUtil bytesFromString: aSymbol)</body></methods><methods><class-id>StompWriter</class-id> <category>writing-attributes</category><body package="Stomp-Core" selector="addClassNameAttributeTo:for:">addClassNameAttributeTo: attributes for: writeObject	^attributes add: (StompConstants klassName -&gt; (self bytesFromIdentifierString: (self classNameOf: writeObject)))</body><body package="Stomp-Core" selector="addClassSpecifierAttributesTo:for:">addClassSpecifierAttributesTo: attributes for: writeObject 	| writeObjectClass |	writeObjectClass := writeObject class.	self addClassNameAttributeTo: attributes for: writeObject.	self context rememberClass: writeObjectClass.			(self context includesEnvironment: writeObjectClass environment)		ifTrue: [| envId |			envId := self context environmentIdOf: writeObjectClass environment.			self addEnvironmentIdAttributeTo: attributes id: envId]		ifFalse: [self addEnvironmentNameAttributeTo: attributes for: writeObject.			self context rememberEnvironment: writeObjectClass environment].</body><body package="Stomp-Core" selector="addEnvironmentIdAttributeTo:id:">addEnvironmentIdAttributeTo: attributes id: envId	^attributes add: (StompConstants environmentId -&gt; envId)</body><body package="Stomp-Core" selector="addEnvironmentNameAttributeTo:for:">addEnvironmentNameAttributeTo: attributes for: writeObject	| env |	self settings useEnvironment ifFalse: [^self].	(self portableUtil shouldWriteEnvironmentNameOf: writeObject) ifFalse: [^self].	env := self portableUtil environmentNameOf: writeObject.	^attributes add: (StompConstants environmentName -&gt; (self bytesFromIdentifierString: env))</body><body package="Stomp-Core" selector="classNameOf:">classNameOf: anObject	| kls |	kls := anObject class.	^ (self portableUtil isMeta: kls) ifTrue: [(self portableUtil soleInstanceOf: kls) name, '$'] ifFalse: [kls name]</body></methods><methods><class-id>StompWriter</class-id> <category>writing-helper</category><body package="Stomp-Core" selector="basicWriteInstVarsOf:">basicWriteInstVarsOf: writeObject 		| instVarNamesWithIndices |	instVarNamesWithIndices := self writtenInstVarNamesWithIndicesOf: writeObject.	self writeMapSize: 1.	self writeArraySize: instVarNamesWithIndices size.	instVarNamesWithIndices do: [:each | super writeObject: (self bytesFromIdentifierString: (each at: 1))].	self writeArraySize: instVarNamesWithIndices size.	instVarNamesWithIndices do: [:nmAndIndex |		| nm idx val | 		nm := nmAndIndex at: 1.		idx := nmAndIndex at: 2.		val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).		self writeObject: val	].</body><body package="Stomp-Core" selector="writeAll:">writeAll: collObject	| sz  |	sz := collObject size. 	self writeArraySize: sz.	collObject stompDo: [:each | self nextPut: each]</body><body package="Stomp-Core" selector="writeBitsOf:">writeBitsOf: writeObject	self writeRawBytes: writeObject stompBytes	</body><body package="Stomp-Core" selector="writeContent:">writeContent: writeObject	writeObject stompWriteContentTo: self</body><body package="Stomp-Core" selector="writeContent:tag:attributes:">writeContent: object tag: tag attributes: attribs	| sz |	sz := 2 + object stompValueContentSize. 	self writeArraySize: sz.	self writeTag: tag.	self writeMapSize: attribs size.	attribs do: [:assoc |		self writePositiveFixNum: assoc key.		super writeObject: assoc value	].	self writeContent: object</body><body package="Stomp-Core" selector="writeIndexFieldsOf:">writeIndexFieldsOf: writeObject	self writeAll: writeObject		</body><body package="Stomp-Core" selector="writeInstVarsOf:">writeInstVarsOf: writeObject 	|  cachedNamesWithIndices |	self settings suppressNilWrite ifTrue: [^self writeNotNilInstVarsOf: writeObject].		(cachedNamesWithIndices := self context instVarNamesWithIndicesOf: writeObject class) == nil ifFalse: [		^ self writeInstVarsOf: writeObject using: cachedNamesWithIndices	].		self basicWriteInstVarsOf: writeObject</body><body package="Stomp-Core" selector="writeInstVarsOf:using:">writeInstVarsOf: writeObject using: cachedNamesWithIndices	| classId |	classId := self context classIdOf: writeObject class ifAbsent:[^ self basicWriteInstVarsOf: writeObject].	self writeArraySize: cachedNamesWithIndices size + 1. 	self writeObject: classId.	cachedNamesWithIndices do: [:nmAndIndex |		| nm idx val | 		nm := nmAndIndex at: 1.		idx := nmAndIndex at: 2.		val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).		self writeObject: val	].</body><body package="Stomp-Core" selector="writeMixedFieldsOf:">writeMixedFieldsOf: writeObject 		| shouldWriteInstanceVariables |	writeObject class instSize = 0 ifTrue: [^self writeIndexFieldsOf: writeObject].		shouldWriteInstanceVariables := writeObject stompShouldWriteInstanceVariables.	shouldWriteInstanceVariables ifTrue: [		self writeObject: writeObject size.		self writeInstVarsOf: writeObject	].	self writeIndexFieldsOf: writeObject</body><body package="Stomp-Core" selector="writeNotNilInstVarsOf:">writeNotNilInstVarsOf: writeObject 	| instVarNamesWithIndices nameAndValues |	instVarNamesWithIndices := self writtenInstVarNamesWithIndicesOf: writeObject.	nameAndValues := OrderedCollection new.	instVarNamesWithIndices		do: [:nmAndIndex | 			| nm idx val | 			nm := nmAndIndex at: 1.			idx := nmAndIndex at: 2.			val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).			val == nil ifFalse: [nameAndValues add: (Array with: (self bytesFromIdentifierString: (nm)) with: val)]].		self writeMapSize: 1.	self writeArraySize: nameAndValues size.	nameAndValues do: [:each | super writeObject: (each at: 1)].	self writeArraySize: nameAndValues size.	nameAndValues do: [:each | self writeObject: (each at: 2)].</body><body package="Stomp-Core" selector="writeTag:">writeTag: tagInt	"tagInt should be 0-255"	self writeStream nextPut: (2r10100001).	self writeStream nextPut: tagInt</body><body package="Stomp-Core" selector="writeVersion">writeVersion	self writeStream nextPutAll: StompConstants header.	self writeStream nextPut: self defaultVersion "1-255"</body><body package="Stomp-Core" selector="writtenInstVarNamesWithIndicesOf:">writtenInstVarNamesWithIndicesOf: writeObject 	| writeObjectClass cachedNamesIndices instVarNames transientInstVarNames instVarIndices |	writeObjectClass := writeObject class.	(cachedNamesIndices := self context instVarNamesWithIndicesOf: writeObjectClass) == nil ifFalse: [^cachedNamesIndices].	instVarNames := writeObjectClass allInstVarNames asOrderedCollection collect: [:each | each asString] .	transientInstVarNames := writeObject stompTransientInstVarNames.	transientInstVarNames := transientInstVarNames collect: [:each | each asString] .	transientInstVarNames do: [:each | instVarNames remove: each ifAbsent:[]].	instVarIndices := self portableUtil instVarIndicesOf: writeObjectClass from: instVarNames.	^ self context rememberInstVarNames: instVarNames indices: instVarIndices of: writeObjectClass.</body></methods><methods><class-id>StompWriter</class-id> <category>stream-like</category><body package="Stomp-Core" selector="nextPut:">nextPut: anObject	self writeStompFrom: anObject</body><body package="Stomp-Core" selector="nextPutAll:">nextPutAll: aCollectionOfObject	aCollectionOfObject do: [:each | self nextPut: each]</body></methods><methods><class-id>StompWriter</class-id> <category>writing-custom</category><body package="Stomp-Core" selector="writePrimitiveValues:">writePrimitiveValues: anArray	"MessagePack types only"	"Never store object refs"	^super writeObject: anArray</body></methods><methods><class-id>StompWriter</class-id> <category>accessing</category><body package="Stomp-Core" selector="context">context	"Answer the value of context"	^ context ifNil: [context := StompWriteContext on: self]</body><body package="Stomp-Core" selector="context:">context: anObject	"Set the value of context"	context := anObject</body><body package="Stomp-Core" selector="portableUtil">portableUtil	^MpPortableUtil stomp</body></methods><methods><class-id>StompWriter</class-id> <category>constants</category><body package="Stomp-Core" selector="defaultVersion">defaultVersion	"Stomp version 1"	^1</body></methods><methods><class-id>StompWriter</class-id> <category>testing</category><body package="Stomp-Core" selector="putReferenceOf:ifExists:">putReferenceOf: anObject ifExists: aBlock	| refId |	refId := self context at: anObject ifAbsent: [].	refId notNil ifTrue: [^aBlock value: refId].		self rememberReferenceOf: anObject</body><body package="Stomp-Core" selector="supportsReferenceFor:">supportsReferenceFor: anObject	^anObject stompSupportsReference: self context	</body></methods><methods><class-id>StompWriter</class-id> <category>debugging</category><body package="Stomp-Core" selector="debugEncode:">debugEncode: bytes	|  encoded counterDic decoder |	encoded := self encode: bytes.	self context objectsDictionary.	counterDic := Dictionary new.	self context objectsDictionary keysAndValuesDo: [:k :v | counterDic at: v put: k].	counterDic inspect.	decoder := StompReader new.	decoder decode: encoded.	decoder context objectsDictionary inspect.	^encoded</body></methods><methods><class-id>StompPortableUtil</class-id> <category>converting</category><body package="Stomp-Core" selector="byteStringFromBytes:">byteStringFromBytes: aByteArray	^aByteArray asString</body><body package="Stomp-Core" selector="bytesFromByteString:">bytesFromByteString: aByteString	^aByteString asByteArray</body><body package="Stomp-Core" selector="bytesFromString:">bytesFromString: aString	^aString asByteArray</body><body package="Stomp-Core" selector="characterFromUnicode:">characterFromUnicode: anInteger	^Character value: anInteger</body><body package="Stomp-Core" selector="colorFromRgbArray:">colorFromRgbArray: rgbArray	^nil</body><body package="Stomp-Core" selector="dateAndTimeFromNanoseconds:">dateAndTimeFromNanoseconds: nanoseconds	^ self timestampFromNanoseconds: nanoseconds</body><body package="Stomp-Core" selector="dateFromSeconds:">dateFromSeconds: seconds	^ Date fromSeconds: seconds</body><body package="Stomp-Core" selector="durationFromNanoseconds:">durationFromNanoseconds: nanoseconds	"^Duration fromNanoseconds: nanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="nanosecondsFromDateAndTime:">nanosecondsFromDateAndTime: timestamp	"Answer the number of nanoseconds since January 1, 1901."	"^timestamp asNanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="nanosecondsFromDuration:">nanosecondsFromDuration: duration	self subclassResponsibility </body><body package="Stomp-Core" selector="stringFromBytes:">stringFromBytes: aByteArray	^aByteArray asString </body><body package="Stomp-Core" selector="timestampFromNanoseconds:">timestampFromNanoseconds: nanoseconds	"^ Timestamp fromNanoseconds: nanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="unicodeFromCharacter:">unicodeFromCharacter: aCharacter	^aCharacter asciiValue</body></methods><methods><class-id>StompPortableUtil</class-id> <category>actions</category><body package="Stomp-Core" selector="bytes:intoOf:">bytes: rawBytes intoOf: bitsClass	"override"	^bitsClass new: rawBytes size</body><body package="Stomp-Core" selector="bytesFrom:">bytesFrom: bitsObject	"override"	^bitsObject	</body><body package="Stomp-Core" selector="classNamed:">classNamed: localClassName	"override"	^ Smalltalk		at: localClassName		ifAbsent: []</body><body package="Stomp-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	"override"	| env |	environmentQualifier ifNil: [^ self classNamed: localClassName].					"Suppose namespace is not supported, so just use Smalltalk"	env :=  Smalltalk.	^ env		at: localClassName		ifAbsent: []</body><body package="Stomp-Core" selector="environmentNameOf:">environmentNameOf: anObject	^#Smalltalk</body><body package="Stomp-Core" selector="instVarIndexOf:for:">instVarIndexOf: aClass for: varName 	"override"	self subclassResponsibility.	^0</body><body package="Stomp-Core" selector="instVarIndicesOf:from:">instVarIndicesOf: aClass from: instVarNames	^ instVarNames collect: [:each |		self instVarIndexOf: aClass for: each	] </body><body package="Stomp-Core" selector="instVarNamed:put:in:">instVarNamed: varName put: value in: anObject	"Note that when varName is invalid, just silently ignore"	| index |	index := self instVarIndexOf: anObject class for: varName.	index = 0 ifTrue: [^self].	anObject instVarAt: index put: value			</body><body package="Stomp-Core" selector="nextAvailable:from:">nextAvailable: size from: stream	"even reached at end, just return contents as-is"	^stream nextAvailable: size</body><body package="Stomp-Core" selector="shouldWriteEnvironmentNameOf:">shouldWriteEnvironmentNameOf: anObject	^((self environmentNameOf: anObject) ~~ #Smalltalk)</body><body package="Stomp-Core" selector="useEnvironmentByDefault">useEnvironmentByDefault	^true</body></methods><methods><class-id>StompPortableUtil</class-id> <category>testing</category><body package="Stomp-Core" selector="isMeta:">isMeta: aBehavior	^aBehavior isMeta</body><body package="Stomp-Core" selector="isWideString:">isWideString: aString	"override"	^false</body><body package="Stomp-Core" selector="isWideSymbol:">isWideSymbol: aSymbol	"override"	^false</body></methods><methods><class-id>StompPortableUtil</class-id> <category>factory</category><body package="Stomp-Core" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpEncodeTypeMapper</body><body package="Stomp-Core" selector="popularClassMap">popularClassMap	"override"	^StompPopularClassMap default</body><body package="Stomp-Core" selector="soleInstanceOf:">soleInstanceOf: aMetaclass	^ aMetaclass soleInstance</body></methods><methods><class-id>StompPortableUtil class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	Default := nil.	DialectSpecificClass := nil</body></methods><methods><class-id>StompPortableUtil class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="default">default	^Default ifNil: [Default := self dialectSpecificClass new]</body></methods><methods><class-id>StompPortableUtil class</class-id> <category>factory</category><body package="Stomp-Core" selector="dialectSpecificClass">dialectSpecificClass	^DialectSpecificClass ifNil: [DialectSpecificClass := self subclasses at: 1]</body><body package="Stomp-Core" selector="dialectSpecificClass:">dialectSpecificClass: aClass	DialectSpecificClass := aClass</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>converting</category><body package="Stomp-VW-Core" selector="byteStringFromBytes:">byteStringFromBytes: aByteArray	| val |	val := aByteArray copy.	ByteString adoptInstance: val.	^val.</body><body package="Stomp-VW-Core" selector="bytesFromByteString:">bytesFromByteString: aByteString	| val |	val := aByteString copy.	ByteArray adoptInstance: val.	^val.</body><body package="Stomp-VW-Core" selector="bytesFromString:">bytesFromString: aString	^aString asByteArrayEncoding: #utf8</body><body package="Stomp-VW-Core" selector="colorFromRgbArray:">colorFromRgbArray: rgbArray	^ColorValue		red: (rgbArray at: 1) asNumber		green: (rgbArray at: 2) asNumber		blue: (rgbArray at: 3) asNumber</body><body package="Stomp-VW-Core" selector="dateFromSeconds:">dateFromSeconds: seconds	^ (Timestamp fromSeconds: seconds) asDate</body><body package="Stomp-VW-Core" selector="durationFromNanoseconds:">durationFromNanoseconds: nanoseconds	^Duration fromNanoseconds: nanoseconds</body><body package="Stomp-VW-Core" selector="nanosecondsFromDateAndTime:">nanosecondsFromDateAndTime: timestamp	"Answer the number of nanoseconds since January 1, 1901."	^timestamp asNanoseconds</body><body package="Stomp-VW-Core" selector="nanosecondsFromDuration:">nanosecondsFromDuration: duration	^ duration asNanoseconds</body><body package="Stomp-VW-Core" selector="stringFromBytes:">stringFromBytes: aByteArray	^aByteArray asStringEncoding: #utf8</body><body package="Stomp-VW-Core" selector="timestampFromNanoseconds:">timestampFromNanoseconds: nanoseconds	^ Timestamp fromNanoseconds: nanoseconds</body><body package="Stomp-VW-Core" selector="unicodeFromCharacter:">unicodeFromCharacter: aCharacter	^aCharacter asInteger</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>actions</category><body package="Stomp-VW-Core" selector="bytes:intoOf:">bytes: rawBytes intoOf: bitsClass	^ rawBytes changeClassTo: bitsClass</body><body package="Stomp-VW-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	"override"	| bindingReference binding env |	environmentQualifier ifNil: [^ self classNamed: localClassName].	bindingReference := BindingReference pathString: environmentQualifier.	binding := bindingReference bindingOrNil ifNil: [^nil].	env :=  binding value.	^ env		at: localClassName		ifAbsent: []</body><body package="Stomp-VW-Core" selector="environmentNameOf:">environmentNameOf: anObject	^anObject class environment name</body><body package="Stomp-VW-Core" selector="instVarIndexOf:for:">instVarIndexOf: aClass for: varName 	^ aClass		instVarIndexFor: varName asString	</body><body package="Stomp-VW-Core" selector="instVarNamed:put:in:">instVarNamed: varName put: value in: anObject	"Note that when varName is invalid, just silently ignore"	| index |	index := anObject class						instVarIndexFor: varName asString.	index = 0 ifTrue: [^self].	anObject instVarAt: index put: value</body><body package="Stomp-VW-Core" selector="shouldWriteEnvironmentNameOf:">shouldWriteEnvironmentNameOf: anObject	| kls nonMeta |	kls := anObject class.	nonMeta := kls isMeta ifTrue: [kls soleInstance] ifFalse: [kls].	(Smalltalk at: nonMeta name ifAbsent: [^true]).	^false</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>factory</category><body package="Stomp-VW-Core" selector="popularClassMap">popularClassMap	"override"	^StompVwPopularClassMap default</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>testing</category><body package="Stomp-VW-Core" selector="isWideString:">isWideString: aString	^aString isByteIndexed not</body><body package="Stomp-VW-Core" selector="isWideSymbol:">isWideSymbol: aSymbol	^aSymbol isByteIndexed not</body></methods><methods><class-id>StompVwPortableUtil class</class-id> <category>class initialization</category><body package="Stomp-VW-Core" selector="initialize">initialize	"StompSqPortableUtil initialize"	| klsName |	super initialize.	klsName := self name.	Smalltalk at: klsName ifPresent: [:p | StompPortableUtil dialectSpecificClass: p].</body></methods><methods><class-id>StompShapeChanger</class-id> <category>actions</category><body package="Stomp-Core" selector="loadAdditions">loadAdditions	"override"</body><body package="Stomp-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	"override"	 self targetInstance stompInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompShapeChanger</class-id> <category>accessing</category><body package="Stomp-Core" selector="targetInstance">targetInstance	"Answer the value of targetInstance"	^ targetInstance</body><body package="Stomp-Core" selector="targetInstance:">targetInstance: anObject	"Set the value of targetInstance"	targetInstance := anObject</body></methods><methods><class-id>StompShapeChanger</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="on:">on: anInstance 	self targetInstance: anInstance</body></methods><methods><class-id>StompShapeChanger class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="on:">on: anInstance 	^ self new on: anInstance;		 yourself</body></methods><methods><class-id>StompBlockShapeChanger</class-id> <category>actions</category><body package="Stomp-Core" selector="loadAdditions">loadAdditions	loadAdditionsBlock ifNotNil: [loadAdditionsBlock value: self targetInstance]</body><body package="Stomp-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	loadInstVarsBlock ifNotNil: [loadInstVarsBlock value: self targetInstance value: varName value: varValue]. 		super loadInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompBlockShapeChanger</class-id> <category>accessing</category><body package="Stomp-Core" selector="loadAdditionsBlock">loadAdditionsBlock	"Answer the value of loadAdditionsBlock"	^ loadAdditionsBlock</body><body package="Stomp-Core" selector="loadAdditionsBlock:">loadAdditionsBlock: anObject	"Set the value of loadAdditionsBlock"	loadAdditionsBlock := anObject</body><body package="Stomp-Core" selector="loadInstVarsBlock">loadInstVarsBlock	"Answer the value of loadInstVarsBlock"	^ loadInstVarsBlock</body><body package="Stomp-Core" selector="loadInstVarsBlock:">loadInstVarsBlock: anObject	"Set the value of loadInstVarsBlock"	loadInstVarsBlock := anObject</body></methods><methods><class-id>StompBlockShapeChanger class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="loadInstVarsBlock:loadAdditionsBlock:">loadInstVarsBlock: loadInstVarsBlock loadAdditionsBlock: loadAdditionsBlock	| inst |	inst := self new.	inst loadInstVarsBlock: loadInstVarsBlock.	inst loadAdditionsBlock: loadAdditionsBlock.	^ inst</body></methods><methods><class-id>StompConstants class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initTupleTags">initTupleTags	"self initTupleTags"	tupleTags := Set new.	tupleTags add: self value.	tupleTags add: self reference.	tupleTags add: self byteString.	tupleTags add: self byteSymbol.	tupleTags add: self wideString.	tupleTags add: self wideSymbol.</body><body package="Stomp-Core" selector="initialize">initialize	"self initialize"	self initTupleTags	</body></methods><methods><class-id>StompConstants class</class-id> <category>tuple tags</category><body package="Stomp-Core" selector="byteString">byteString	^16r04</body><body package="Stomp-Core" selector="byteSymbol">byteSymbol	^16r05</body><body package="Stomp-Core" selector="reference">reference	^16r03</body><body package="Stomp-Core" selector="value">value	^16r02</body><body package="Stomp-Core" selector="wideString">wideString	^16r06</body><body package="Stomp-Core" selector="wideSymbol">wideSymbol	^16r07</body></methods><methods><class-id>StompConstants class</class-id> <category>attribute-tags</category><body package="Stomp-Core" selector="classCode">classCode	^16r15</body><body package="Stomp-Core" selector="classId">classId	^16r12</body><body package="Stomp-Core" selector="environmentId">environmentId	^16r14</body><body package="Stomp-Core" selector="environmentName">environmentName	^16r13</body><body package="Stomp-Core" selector="klassName">klassName	^16r11</body></methods><methods><class-id>StompConstants class</class-id> <category>accessing</category><body package="Stomp-Core" selector="header">header	^'SP' asByteArray</body><body package="Stomp-Core" selector="tupleTags">tupleTags	^tupleTags</body></methods><methods><class-id>StompConstants class</class-id> <category>actions</category><body package="Stomp-Core" selector="isTupleTag:">isTupleTag: tag	^tag isInteger and: [self tupleTags includes: tag]</body></methods><methods><class-id>StompWarning</class-id> <category>accessing</category><body package="Stomp-Core" selector="className">className	className ifNil: [^ className].	^className asSymbol</body><body package="Stomp-Core" selector="className:">className: aValue	className := aValue</body><body package="Stomp-Core" selector="context">context	^context</body><body package="Stomp-Core" selector="context:">context: aValue	context := aValue</body><body package="Stomp-Core" selector="element">element	^ element</body><body package="Stomp-Core" selector="element:">element: aValue 	element := aValue</body></methods><methods><class-id>StompWarning</class-id> <category>signaling</category><body package="Stomp-Core" selector="signal:context:">signal: aClassName context: dictionary 	self class suppressSignaling ifTrue: [^self].	self className: aClassName.	self context: dictionary.	^MpPortableUtil default signalException: self</body></methods><methods><class-id>StompWarning</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="defaultAction">defaultAction	self class suppressTranscriptLogging ifFalse: [Transcript cr; show: '#warning# ' , self description].	self resume</body></methods><methods><class-id>StompWarning class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:">signal: className	^self signal: className context: nil </body><body package="Stomp-Core" selector="signal:context:">signal: className context: dictionary 	^ self new signal: className context: dictionary </body></methods><methods><class-id>StompWarning class</class-id> <category>accessing</category><body package="Stomp-Core" selector="suppressSignaling">suppressSignaling	^suppressSignaling ifNil: [suppressSignaling := false].</body><body package="Stomp-Core" selector="suppressSignaling:">suppressSignaling: anObject	suppressSignaling := anObject</body><body package="Stomp-Core" selector="suppressTranscriptLogging">suppressTranscriptLogging	^suppressTranscriptLogging ifNil: [suppressTranscriptLogging := false]</body><body package="Stomp-Core" selector="suppressTranscriptLogging:">suppressTranscriptLogging: anObject	suppressTranscriptLogging := anObject</body></methods><methods><class-id>StompWarning class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	"StompWarning initialize"	suppressSignaling := nil.	suppressTranscriptLogging := nil</body></methods><methods><class-id>StompClassNotFound</class-id> <category>factory</category><body package="Stomp-Core" selector="berstReadValue">berstReadValue 	^ nil</body><body package="Stomp-Core" selector="stompReadValue">stompReadValue 	^ nil</body><body package="Stomp-Core" selector="unresolvedClass">unresolvedClass	"By default my class act as an unresolved class, which instantiate nil"	^self class</body></methods><methods><class-id>StompClassNotFound</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="defaultAction">defaultAction	Transcript cr; show: '#warning# ' , self description.	^ self unresolvedClass</body><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompClassNotFound</class-id> <category>accessing</category><body package="Stomp-Core" selector="environmentName">environmentName	"Answer the value of environmentName"	environmentName ifNil: [^ environmentName].	^ environmentName</body><body package="Stomp-Core" selector="environmentName:">environmentName: anObject	"Set the value of environmentName"	environmentName := anObject</body></methods><methods><class-id>StompClassNotFound class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:environment:context:">signal: className environment: envName context: dictionary 	| inst |	inst := self new.	inst environmentName: envName.	^ inst signal: className context: dictionary </body></methods><methods><class-id>StompContext</class-id> <category>actions</category><body package="Stomp-Core" selector="at:">at: key	^self objectsDictionary at: key</body><body package="Stomp-Core" selector="at:ifAbsent:">at: key ifAbsent: block	^self objectsDictionary at: key ifAbsent: block</body><body package="Stomp-Core" selector="at:ifAbsentPut:">at: key ifAbsentPut: value	^self objectsDictionary at: key ifAbsentPut: value</body><body package="Stomp-Core" selector="at:put:">at: key put: value	^self objectsDictionary at: key put: value</body><body package="Stomp-Core" selector="includesKey:">includesKey: key 	^self objectsDictionary includesKey: key</body><body package="Stomp-Core" selector="keys">keys	^self objectsDictionary keys</body><body package="Stomp-Core" selector="keysAndValuesDo:">keysAndValuesDo: block	^self objectsDictionary keysAndValuesDo: block</body><body package="Stomp-Core" selector="removeKey:">removeKey: key 	^self objectsDictionary removeKey: key</body><body package="Stomp-Core" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: block	^self objectsDictionary removeKey: key ifAbsent: block</body><body package="Stomp-Core" selector="size">size	^self objectsDictionary size</body><body package="Stomp-Core" selector="values">values	^self objectsDictionary values</body></methods><methods><class-id>StompContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="objectsDictionary">objectsDictionary	"Answer the value of objectsDictionary"	^ objectsDictionary ifNil: [objectsDictionary := self objectDictionaryClass new: 20]</body><body package="Stomp-Core" selector="objectsDictionary:">objectsDictionary: anObject	"Set the value of objectsDictionary"	objectsDictionary := anObject</body><body package="Stomp-Core" selector="requestor">requestor	^ requestor</body><body package="Stomp-Core" selector="requestor:">requestor: anObject	"Set the value of requestor"	requestor := anObject</body><body package="Stomp-Core" selector="settings">settings	^self requestor settings</body></methods><methods><class-id>StompContext</class-id> <category>defaults</category><body package="Stomp-Core" selector="objectDictionaryClass">objectDictionaryClass	^IdentityDictionary</body></methods><methods><class-id>StompContext</class-id> <category>printing</category><body package="Stomp-Core" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: '('.	aStream cr.	self objectsDictionary associationsDo: [:assoc |		assoc printOn: aStream.		aStream cr.	].	aStream nextPutAll: ')'.</body></methods><methods><class-id>StompContext class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="on:">on: requestor 	^ self new requestor: requestor;		 yourself</body></methods><methods><class-id>StompWriteContext</class-id> <category>actions</category><body package="Stomp-Core" selector="classIdOf:ifAbsent:">classIdOf: aClass ifAbsent: block	^ self classesDictionary at: aClass ifAbsent: block</body><body package="Stomp-Core" selector="environmentIdOf:">environmentIdOf: aClass	^ self environmentsDictionary at: aClass</body><body package="Stomp-Core" selector="includesClass:">includesClass: aClass	^ self classesDictionary includesKey: aClass</body><body package="Stomp-Core" selector="includesEnvironment:">includesEnvironment: anEnvironment	self settings useEnvironment ifFalse: [^false].	^ self environmentsDictionary includesKey: anEnvironment</body><body package="Stomp-Core" selector="instVarNamesWithIndicesOf:">instVarNamesWithIndicesOf: aClass	^ self instVarNamesWithIndicesDictionary at: aClass ifAbsent: []</body><body package="Stomp-Core" selector="rememberClass:">rememberClass: aClass	^ self classesDictionary at: aClass put: (self classesDictionary size)</body><body package="Stomp-Core" selector="rememberEnvironment:">rememberEnvironment: anEnvironment	self settings useEnvironment ifFalse: [^self].	anEnvironment name == #Smalltalk ifTrue: [^self].	^ self environmentsDictionary at: anEnvironment put: (self environmentsDictionary size)</body><body package="Stomp-Core" selector="rememberInstVarNames:indices:of:">rememberInstVarNames: instVarNames indices: instVarIndices of: aClass	| ord |	ord := OrderedCollection new: instVarNames size.	instVarNames with: instVarIndices do: [:name :idx | ord add: (Array with: name with: idx)]. 	self instVarNamesWithIndicesDictionary at: aClass put: ord.	^ord</body><body package="Stomp-Core" selector="rememberReferenceOf:">rememberReferenceOf: originalObject	self at: originalObject put: self size.</body></methods><methods><class-id>StompWriteContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="classesDictionary">classesDictionary	^ classesDictionary ifNil: [classesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="classesDictionary:">classesDictionary: anObject	"Set the value of classesDictionary"	classesDictionary := anObject</body><body package="Stomp-Core" selector="environmentsDictionary">environmentsDictionary	^ environmentsDictionary ifNil: [environmentsDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="environmentsDictionary:">environmentsDictionary: anObject	"Set the value of environmentsDictionary"	environmentsDictionary := anObject</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary">instVarNamesWithIndicesDictionary	^ instVarNamesWithIndicesDictionary ifNil: [instVarNamesWithIndicesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary:">instVarNamesWithIndicesDictionary: anObject	"Set the value of instVarNamesWithIndicesDictionary"	instVarNamesWithIndicesDictionary := anObject</body></methods><methods><class-id>StompError class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:">signal: aString	| inst |	inst := self new.	inst messageText: aString.	^MpPortableUtil default signalException: inst</body></methods><methods><class-id>StompInvalidDeserialization</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompReadContext</class-id> <category>renaming</category><body package="Stomp-Core" selector="registerClassOldName:for:">registerClassOldName: oldClassNameSymbol for: existingClass	^ self registerClassOldName: oldClassNameSymbol in: nil for: existingClass</body><body package="Stomp-Core" selector="registerClassOldName:in:for:">registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier for: existingClass	| key |	key := oldEnvironmentQualifier isNil				ifTrue: [oldClassNameSymbol]				ifFalse: [Array with: oldEnvironmentQualifier with: oldClassNameSymbol].	^ self classAliasesDictionary at: key put: existingClass</body><body package="Stomp-Core" selector="registerClassOldName:in:shapeChanger:for:">registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier shapeChanger: shapeChangerClass for: existingClass	self registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier for: existingClass.	self registerShapeChanger: shapeChangerClass for: existingClass.</body><body package="Stomp-Core" selector="registerClassOldName:shapeChanger:for:">registerClassOldName: oldClassNameSymbol shapeChanger: shapeChangerClass for: existingClass	self registerClassOldName: oldClassNameSymbol for: existingClass.	self registerShapeChanger: shapeChangerClass for: existingClass.</body></methods><methods><class-id>StompReadContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="classAliasesDictionary">classAliasesDictionary	^ classAliasesDictionary ifNil: [classAliasesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="classAliasesDictionary:">classAliasesDictionary: anObject	"Set the value of classAliasesDictionary"	classAliasesDictionary := anObject</body><body package="Stomp-Core" selector="classIdsDictionary">classIdsDictionary		^ classIdsDictionary ifNil: [classIdsDictionary := Dictionary new]</body><body package="Stomp-Core" selector="classIdsDictionary:">classIdsDictionary: anObject	"Set the value of classIdsDictionary"	classIdsDictionary := anObject</body><body package="Stomp-Core" selector="environmentNamesDictionary">environmentNamesDictionary	^environmentNamesDictionary ifNil: [environmentNamesDictionary := Dictionary new]</body><body package="Stomp-Core" selector="environmentNamesDictionary:">environmentNamesDictionary: anObject	environmentNamesDictionary := anObject</body><body package="Stomp-Core" selector="fieldsInfo">fieldsInfo	"Answer the value of mixedFieldHint"	^ fieldsInfo</body><body package="Stomp-Core" selector="fieldsInfo:">fieldsInfo: anObject	"Set the value of mixedFieldHint"	fieldsInfo := anObject</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary">instVarNamesWithIndicesDictionary	^ instVarNamesWithIndicesDictionary ifNil: [instVarNamesWithIndicesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary:">instVarNamesWithIndicesDictionary: anObject	"Set the value of instVarNamesWithIndicesDictionary"	instVarNamesWithIndicesDictionary := anObject</body><body package="Stomp-Core" selector="shapeChangersDictionary">shapeChangersDictionary	^ shapeChangersDictionary ifNil: [shapeChangersDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="shapeChangersDictionary:">shapeChangersDictionary: anObject	"Set the value of shapeChangersDictionary"	shapeChangersDictionary := anObject</body></methods><methods><class-id>StompReadContext</class-id> <category>actions</category><body package="Stomp-Core" selector="classAt:">classAt: classId	^self classIdsDictionary at: classId ifAbsent: []</body><body package="Stomp-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	| qualifier isClassClass localClassNameSize className foundClass |	qualifier := self settings useEnvironment ifTrue: [environmentQualifier].		isClassClass := false.	localClassNameSize := localClassName size.	className := ((localClassName at: (localClassNameSize)) = $$)				ifTrue: [isClassClass := true.					localClassName copyFrom: 1 to: (localClassNameSize-1)]				ifFalse: [localClassName].					foundClass := self mappedClassAt: className asSymbol in: qualifier.		isClassClass ifTrue: [foundClass := foundClass class].		^ foundClass</body><body package="Stomp-Core" selector="environmentNameAt:">environmentNameAt: envId	^ self environmentNamesDictionary at: envId ifAbsent: [].</body><body package="Stomp-Core" selector="instVarNamesWithIndicesAt:">instVarNamesWithIndicesAt: classId	| klass |	klass := self classAt: classId.	^ self instVarNamesWithIndicesDictionary at: klass ifAbsent: [#()]</body><body package="Stomp-Core" selector="rememberClass:">rememberClass: aClass	^ self classIdsDictionary at: self classIdsDictionary size put: aClass</body><body package="Stomp-Core" selector="rememberEnvironmentName:">rememberEnvironmentName: aString	^ self environmentNamesDictionary at: (self environmentNamesDictionary size) put: aString</body><body package="Stomp-Core" selector="rememberInstVarNames:indices:of:">rememberInstVarNames: instVarNames indices: instVarIndices of: aClass	| ord |	ord := OrderedCollection new: instVarNames size.	instVarNames with: instVarIndices do: [:name :idx | ord add: (Array with: name with: idx)]. 	self instVarNamesWithIndicesDictionary at: aClass put: ord.	^ord</body></methods><methods><class-id>StompReadContext</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="clearFieldsInfo">clearFieldsInfo	fieldsInfo := nil</body></methods><methods><class-id>StompReadContext</class-id> <category>private</category><body package="Stomp-Core" selector="mappedClassAt:in:">mappedClassAt: classNameSymbol in: environmentQualifier 	| classNameSymbolOrNewClass |	classNameSymbolOrNewClass := self mappedClassNameAt: classNameSymbol asSymbol in: environmentQualifier.	^ classNameSymbolOrNewClass isBehavior 		ifTrue: [classNameSymbolOrNewClass]		ifFalse: [StompPortableUtil default classNamed: classNameSymbolOrNewClass in: environmentQualifier].</body><body package="Stomp-Core" selector="mappedClassNameAt:in:">mappedClassNameAt: classNameSymbol in: environmentQualifier 	| key |	key := environmentQualifier isNil				ifTrue: [classNameSymbol]				ifFalse: [Array with: environmentQualifier with: classNameSymbol].	^ self classAliasesDictionary		at: key		ifAbsent: [classNameSymbol]</body></methods><methods><class-id>StompReadContext</class-id> <category>shape changing</category><body package="Stomp-Core" selector="registerShapeChanger:for:">registerShapeChanger: shapeChangerObject for: existingClass	^self shapeChangersDictionary at: existingClass put: shapeChangerObject</body><body package="Stomp-Core" selector="registerShapeChangerRenameBy:for:">registerShapeChangerRenameBy: loadInstVarsBlock for: existingClass	^self registerShapeChangerRenameBy: loadInstVarsBlock initializeBy: nil for: existingClass</body><body package="Stomp-Core" selector="registerShapeChangerRenameBy:initializeBy:for:">registerShapeChangerRenameBy: loadInstVarsBlock initializeBy: loadAdditionsBlock for: existingClass	| changer |	changer := StompBlockShapeChanger loadInstVarsBlock: loadInstVarsBlock loadAdditionsBlock: loadAdditionsBlock.	^self shapeChangersDictionary at: existingClass put: changer</body><body package="Stomp-Core" selector="shapeChangerFor:">shapeChangerFor: existingClass	shapeChangersDictionary ifNil: [^nil].	^self shapeChangersDictionary at: existingClass ifAbsent: []</body></methods><methods><class-id>StompReadContext</class-id> <category>defaults</category><body package="Stomp-Core" selector="objectDictionaryClass">objectDictionaryClass	^Dictionary</body></methods><methods><class-id>StompInvalidSerialization</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompFieldsInfo</class-id> <category>accessing</category><body package="Stomp-Core" selector="indexFieldSize">indexFieldSize	"Answer the value of indexFieldSize"	^ indexFieldSize</body><body package="Stomp-Core" selector="indexFieldSize:">indexFieldSize: anObject	"Set the value of indexFieldSize"	indexFieldSize := anObject</body><body package="Stomp-Core" selector="type">type	"Answer the value of type"	^ type</body><body package="Stomp-Core" selector="type:">type: anObject	"Set the value of type"	type := anObject</body></methods><methods><class-id>StompFieldsInfo</class-id> <category>testing</category><body package="Stomp-Core" selector="isMixedFields">isMixedFields	^ self type == #mixedFields</body><body package="Stomp-Core" selector="isPureIndexFields">isPureIndexFields	^ self type == #pureIndexFields</body></methods><methods><class-id>StompFieldsInfo class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="mixedFields">mixedFields	^ self type: #mixedFields</body><body package="Stomp-Core" selector="pureIndexFields">pureIndexFields	^ self type: #pureIndexFields</body><body package="Stomp-Core" selector="pureIndexFieldsSized:">pureIndexFieldsSized: numOfFields	^ self pureIndexFields indexFieldSize: numOfFields</body><body package="Stomp-Core" selector="type:">type: typeSymbol	^ self new type: typeSymbol; yourself</body></methods><methods><class-id>StompReader</class-id> <category>reading-helper</category><body package="Stomp-Core" selector="readBitsOf:">readBitsOf: aClass	^aClass stompFromBytes: self basicReadObject.</body><body package="Stomp-Core" selector="readCollectionFieldsInto:">readCollectionFieldsInto: anInstance	| size |	size := self readSizeOfArray.	^ self readCollectionFieldsInto: anInstance sized: size</body><body package="Stomp-Core" selector="readCollectionFieldsInto:sized:">readCollectionFieldsInto: anInstance sized: size		anInstance class isVariable ifTrue: [^ self readIndexFieldsInto: anInstance sized: size].	1 to: size do:  [:idx | 		anInstance stompAdd: self readObject at: idx	].	^ anInstance</body><body package="Stomp-Core" selector="readIndexFieldsInto:sized:">readIndexFieldsInto: anInstance sized: size	1 to: size do:  [:idx | 		anInstance stompAt: idx put: self readObject	].	^ anInstance</body><body package="Stomp-Core" selector="readInstVarsInto:">readInstVarsInto: anInstance	| type arraySize varNames varIndices valueSize namesWithIndices values |	type := self readType. 	arraySize := ((type bitShift: -4) = 2r1001)		ifTrue: [type bitAnd: 16rF]		ifFalse: [type = 16rDC ifTrue: [MpPortableUtil default readUint16From: self readStream]].	arraySize == nil ifFalse: [^ self readInstVarsInto: anInstance fromInstVarReferenceArraySized: arraySize].		varNames := self basicReadObject collect: [:each | self identifierStringFromBytes: each].	varIndices := self portableUtil instVarIndicesOf: anInstance class from: varNames.	namesWithIndices := self context rememberInstVarNames: varNames indices: varIndices of: anInstance class.		valueSize := self readSizeOfArray.	values := OrderedCollection new: valueSize.	valueSize timesRepeat: [values add: (self readObject)].	^ self readInstVarsInto: anInstance namesWithIndices: namesWithIndices values: values</body><body package="Stomp-Core" selector="readInstanceContentAt:">readInstanceContentAt: classId	| actualClass |	actualClass := self context classAt: classId.	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentClassCoded:">readInstanceContentClassCoded: clsCode	| actualClass |	actualClass := self portableUtil popularClassMap classAt: clsCode.	actualClass ifNil: [actualClass :=  StompClassNotFound							signal: clsCode printString context: self context].	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentClassNamed:in:">readInstanceContentClassNamed: clsName in: envName	| actualClass |	actualClass := self context classNamed: clsName in: envName.	actualClass ifNil: [actualClass :=  StompClassNotFound							signal: clsName environment: envName context: self context].	self context rememberClass: actualClass. 	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentOf:">readInstanceContentOf: aClass	| inst newInst newKey |	inst := aClass stompCreateInstanceFrom: self.	newKey := self remember: inst.	aClass stompLoadContentsOnCreation ifFalse: [inst stompReadContentFrom: self].	self initializeInstance: inst.	newInst := inst stompReadValue.	newKey == nil ifFalse: [self remember: newInst at: newKey].	^ newInst</body><body package="Stomp-Core" selector="readSizeOfArray">readSizeOfArray	^ self readSizeOfArrayIfMatched: self readType</body><body package="Stomp-Core" selector="readSizeOfArrayIfMatched:">readSizeOfArrayIfMatched: type	((type bitShift: -4) = 2r1001) ifTrue: [^ type bitAnd: 16rF].	type = MpConstants array16		ifTrue: [^ MpPortableUtil default readUint16From: self readStream].	type = MpConstants array32		ifTrue: [^ MpPortableUtil default readUint32From: self readStream].	^-1</body><body package="Stomp-Core" selector="readUIntIfMatched:">readUIntIfMatched: type	(type &lt;= 16r7F) ifTrue: [^ self readPositiveFixNum: type].	type = MpConstants uint8		ifTrue: [^ self readUint8].	type = MpConstants uint16		ifTrue: [^ self readUint16].	type = MpConstants uint32		ifTrue: [^ self readUint32].	type = MpConstants uint64		ifTrue: [^ self readUint64].	^-1</body></methods><methods><class-id>StompReader</class-id> <category>private</category><body package="Stomp-Core" selector="basicReadObject">basicReadObject	"Never remembering"	^(MpDecoder on: self readStream) readObject</body><body package="Stomp-Core" selector="identifierStringFromBytes:">identifierStringFromBytes: byteArray 	byteArray ifNil: [^nil].	^ self settings supportsMultibyteIdentifiers		ifTrue: [self portableUtil stringFromBytes: byteArray]			ifFalse: [byteArray asString]</body><body package="Stomp-Core" selector="initializeInstance:">initializeInstance: instance 	| shapeChangerClass |	instance stompInitialize.	shapeChangerClass := self context shapeChangerFor: instance class.	shapeChangerClass == nil ifFalse: [(shapeChangerClass on: instance) loadAdditions]</body><body package="Stomp-Core" selector="readIdentifierString">readIdentifierString	| type sz |	type := self readType.	(sz := type bitAnd: 2r01011111 &lt;= 31) ifTrue: [		^ self identifierStringFromBytes: (self readStream next: sz)	].	type = MpConstants raw16 ifTrue: [^ self identifierStringFromBytes: super readRaw16].	type = MpConstants raw32 ifTrue: [^ self identifierStringFromBytes: super readRaw32].	</body></methods><methods><class-id>StompReader</class-id> <category>factory</category><body package="Stomp-Core" selector="createDictionary:">createDictionary: size	| dic |	dic := super createDictionary: size.	self remember: dic.	^dic</body><body package="Stomp-Core" selector="settingsClass">settingsClass	^StompSettings</body></methods><methods><class-id>StompReader</class-id> <category>reading-attributes</category><body package="Stomp-Core" selector="readValueWithAttributes:">readValueWithAttributes: attribDict	| clsName envName |		clsName := self identifierStringFromBytes: (attribDict at: StompConstants klassName ifAbsent: []).	envName := self identifierStringFromBytes: (attribDict at: StompConstants environmentName ifAbsent: []).	envName		ifNil: 			[envName := self context						environmentNameAt: (attribDict at: StompConstants environmentId ifAbsent: [])]		ifNotNil: [self context rememberEnvironmentName: envName].	^ self readInstanceContentClassNamed: clsName in: envName</body></methods><methods><class-id>StompReader</class-id> <category>dispatching</category><body package="Stomp-Core" selector="readArraySized:">readArraySized: size 	size = 0 ifTrue: [| arr | self remember: (arr := self createArray: 0). ^arr].	^self readArraySized: size atFirstTyped: self readType</body><body package="Stomp-Core" selector="readArraySized:atFirst:">readArraySized: size atFirst: firstElem	| array |	array := self createArray: size.	self remember: array.	array at: 1 put: firstElem.	2 to: size do: [:idx | array at: idx put: self readObject].	^array</body><body package="Stomp-Core" selector="readArraySized:atFirstTyped:">readArraySized: size atFirstTyped: firstType	| array firstElem |	array := self createArray: size.	self remember: array.	firstElem := self readObjectOf: firstType.	array at: 1 put: firstElem.	2 to: size do: [:idx | array at: idx put: self readObject].	^array</body><body package="Stomp-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: type ifNotApplied: aBlock	(type between: 16r90 and: 16r9F) ifTrue: [^ self readFixArray: type].	^super readObjectOf: type ifNotApplied: aBlock</body><body package="Stomp-Core" selector="readSmallArraySized:">readSmallArraySized: size 	| firstType |	size = 0 ifTrue: [| arr | self remember: (arr := self createArray: 0). ^arr].	firstType := self readType.	firstType = 16rA1 ifTrue: [| firstByte |			firstByte := self readStream next.			^ (StompConstants isTupleTag: firstByte)				ifTrue: [self readTupleBy: firstByte]				ifFalse: [self						readArraySized: size						atFirst: (ByteArray with: firstByte)]].	^self readArraySized: size atFirstTyped: firstType</body><body package="Stomp-Core" selector="readTupleBy:">readTupleBy: tag 	tag = StompConstants value ifTrue: [^self readValue].	tag = StompConstants reference ifTrue: [^self readReference].	tag = StompConstants byteString ifTrue: [^self readByteString].	tag = StompConstants byteSymbol ifTrue: [^self readByteSymbol].	tag = StompConstants wideString ifTrue: [^self readWideString].	tag = StompConstants wideSymbol ifTrue: [^self readWideString].	</body></methods><methods><class-id>StompReader</class-id> <category>reading-dispatched</category><body package="Stomp-Core" selector="readByteString">readByteString"	| type bytes |	type := self readType.	type = MpConstants raw16		ifTrue: [bytes := super readRaw16]		ifFalse: 			[type = MpConstants raw32				ifTrue: [bytes := super readRaw32]				ifFalse: [bytes := super readFixRaw: type]]."	^self portableUtil byteStringFromBytes: self basicReadObject</body><body package="Stomp-Core" selector="readByteSymbol">readByteSymbol	^self readByteString asSymbol</body><body package="Stomp-Core" selector="readReference">readReference	| refId |	refId := self readObject.	^(self context at: refId) yourself</body><body package="Stomp-Core" selector="readValue">readValue	| type attributesSize attribDict newInst |	type := self readType.	(type bitShift: -4) = 2r1000 ifFalse: [ | id |		id := self readObjectOf: type.		^ id &lt; 0 			ifTrue: [self readInstanceContentClassCoded: id negated]			ifFalse: [self readInstanceContentAt: id]	].	attributesSize := type bitAnd: 16rF.	attributesSize = 1 ifTrue: [ | key value |		key := self readPositiveFixNum: self readStream next.		value := self basicReadObject.		key = StompConstants klassName ifTrue: [^ self readInstanceContentClassNamed: (self identifierStringFromBytes: value) in: nil].	].	attribDict := Dictionary new: attributesSize.	1 to: attributesSize do: [:idx |		attribDict at: (self readPositiveFixNum: self readStream next) put: self basicReadObject	].	newInst :=  self readValueWithAttributes: attribDict.	^newInst	</body><body package="Stomp-Core" selector="readWideString">readWideString	^self portableUtil stringFromBytes: self basicReadObject</body><body package="Stomp-Core" selector="readWideSymbol">readWideSymbol	^self readWideString asSymbol</body></methods><methods><class-id>StompReader</class-id> <category>decoding</category><body package="Stomp-Core" selector="decodeFrom:">decodeFrom: aStream	| pos |	self readStream: aStream "binary".	pos := aStream position.	((self portableUtil nextAvailable: 2 from: aStream) = StompConstants header) ifTrue: [		self version: aStream next asInteger.	]. 	aStream position: pos. 	^self decode</body></methods><methods><class-id>StompReader</class-id> <category>accessing</category><body package="Stomp-Core" selector="context">context	"Answer the value of context"	^ context ifNil: [context := StompReadContext on: self]</body><body package="Stomp-Core" selector="context:">context: anObject	"Set the value of context"	context := anObject</body><body package="Stomp-Core" selector="portableUtil">portableUtil	^MpPortableUtil stomp</body><body package="Stomp-Core" selector="version">version	"Answer the value of version"	^ version</body><body package="Stomp-Core" selector="version:">version: anObject	"Set the value of version"	version := anObject</body></methods><methods><class-id>StompReader</class-id> <category>remembering</category><body package="Stomp-Core" selector="remember:">remember: anObject	^ self remember: anObject at: self context size	</body><body package="Stomp-Core" selector="remember:at:">remember: anObject at: key	anObject class = StompClassNotFound ifTrue: [		self context at: key put: nil.		^ key	].	(self supportsReferenceFor: anObject) ifFalse: [^nil]. 	self context at: key put: anObject.	^ key</body></methods><methods><class-id>StompReader</class-id> <category>reading-primitives</category><body package="Stomp-Core" selector="readFixArray:">readFixArray: firstByte	| size |	size := firstByte bitAnd: 16rF.	^ self readSmallArraySized: size</body><body package="Stomp-Core" selector="readFixRaw:">readFixRaw: type	| bytes |	bytes := super readFixRaw: type.	self remember: bytes.	^bytes</body><body package="Stomp-Core" selector="readRaw16">readRaw16	| bytes |	bytes := super readRaw16.	self remember: bytes.	^bytes</body><body package="Stomp-Core" selector="readRaw32">readRaw32	| bytes |	bytes := super readRaw32.	self remember: bytes.	^bytes</body></methods><methods><class-id>StompReader</class-id> <category>reading-custom</category><body package="Stomp-Core" selector="readPrimitiveValues">readPrimitiveValues	"Assuming &lt;= 15 fields"	| inst size |	size := self readStream next bitAnd: 16rF.	inst := self createArray: size.	size = 0 ifTrue: [^ inst].	^ super readArraySized: size</body></methods><methods><class-id>StompReader</class-id> <category>stream-like</category><body package="Stomp-Core" selector="next">next	^self readObject</body></methods><methods><class-id>StompReader</class-id> <category>reading-instance variables</category><body package="Stomp-Core" selector="readInstVarsInto:fromInstVarReferenceArraySized:">readInstVarsInto: anInstance fromInstVarReferenceArraySized: arraySize	| id  namesWithIndices values |	id :=  self basicReadObject.	namesWithIndices := self context instVarNamesWithIndicesAt: id.	values := Array new: namesWithIndices size.	1 to: values size do: [:idx | values at: idx put: self readObject].	self readInstVarsInto: anInstance namesWithIndices: namesWithIndices values: values</body><body package="Stomp-Core" selector="readInstVarsInto:namesWithIndices:values:">readInstVarsInto: anInstance namesWithIndices: varNamesWithIndices values: varValues	| shapeChangerClass |	shapeChangerClass := self context shapeChangerFor: anInstance class.	shapeChangerClass ifNil: [ 		varNamesWithIndices with: varValues do: [:nameWithIndex :value |			anInstance stompInstVarAt: (nameWithIndex at: 2) named: (nameWithIndex at: 1) put: value].	] ifNotNil: [ | shapeChanger |		shapeChanger := shapeChangerClass on: anInstance.		varNamesWithIndices with: varValues do: [:nameWithIndex :value | 			shapeChanger loadInstVarAt: (nameWithIndex at: 2) named: (nameWithIndex at: 1) put: value].	].			^anInstance</body></methods><methods><class-id>StompReader</class-id> <category>testing</category><body package="Stomp-Core" selector="supportsReferenceFor:">supportsReferenceFor: anObject	^anObject stompSupportsReference: self context	</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>*stomp-core</category><body package="Stomp-Core" selector="stomp">stomp	^self default stompUtil</body></methods><methods><class-id>MpPortableUtil</class-id> <category>*Stomp-core-accessing</category><body package="Stomp-Core" selector="stompUtil">stompUtil	^ StompPortableUtil default</body></methods><methods><class-id>Core.DwordArray class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	| bytes |	bytes := rawBytes.	UninterpretedBytes isBigEndian ifFalse: [bytes fourByteEndiannessSwap].	^bytes changeClassTo: self</body></methods><methods><class-id>Core.DwordArray</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompBytes">stompBytes	| bytes |	bytes := self copy changeClassTo: ByteArray.	UninterpretedBytes isBigEndian ifFalse: [bytes fourByteEndiannessSwap].	^bytes</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rgbArray |	rgbArray := stompReader readPrimitiveValues.	^ StompPortableUtil default colorFromRgbArray: rgbArray	</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rgbArray |	rgbArray := Array with: self red asDouble  with: self green asDouble with: self blue asDouble.	stompWriter writePrimitiveValues: rgbArray.</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>*Stomp-VW-Core-reading</category><body package="Stomp-VW-Core" selector="stompAt:put:">stompAt: index put: aValue	self addLastNoCheck: aValue</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-VW-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeAll: self.</body></methods><methods><class-id>UUID</class-id> <category>*Stomp-Squeak-Core-testing</category><body package="Stomp-VW-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-VW-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default timestampFromNanoseconds: stompReader readObject</body></methods><methods><class-id>Core.Timestamp</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default nanosecondsFromDateAndTime: self)</body></methods><methods><class-id>Core.Set</class-id> <category>*Stomp-VW-Core-reading</category><body package="Stomp-VW-Core" selector="stompAt:put:">stompAt: index put: aValue	^self stompAdd: aValue at: index</body></methods><methods><class-id>Core.WordArray class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	| bytes |	bytes := rawBytes.	UninterpretedBytes isBigEndian ifFalse: [bytes twoByteEndiannessSwap].	^bytes changeClassTo: self</body></methods><methods><class-id>Core.WordArray</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompBytes">stompBytes	| bytes |	bytes := self copy changeClassTo: ByteArray.	UninterpretedBytes isBigEndian ifFalse: [bytes twoByteEndiannessSwap].	^bytes</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompAfterWrite">stompAfterWrite</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompAt:put:">stompAt: index put: aValue 	"override if you like"	self basicAt: index put: aValue</body><body package="Stomp-Core" selector="stompBasicReadContentFrom:">stompBasicReadContentFrom: stompReader 	| fieldsInfo |	self class isFixed ifTrue: [^ stompReader readInstVarsInto: self].		fieldsInfo := stompReader context fieldsInfo.	fieldsInfo isPureIndexFields ifTrue: [ ^ stompReader readIndexFieldsInto: self sized: fieldsInfo indexFieldSize].	fieldsInfo isMixedFields ifTrue: [		self stompShouldWriteInstanceVariables ifTrue: [stompReader readInstVarsInto: self].		stompReader readIndexFieldsInto: self sized: stompReader readSizeOfArray.	].		^self</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompBytes">stompBytes	"For bytes, words object"	"override"	^StompPortableUtil default bytesFrom: self </body><body package="Stomp-Core" selector="stompDo:">stompDo: aBlock	self class isFixed ifTrue:[		"I'm not an Collection - so just write myself"		^ aBlock value: self	].	self size = 0 ifTrue: [^ aBlock value: self].	1 to: self size do: [:idx |		aBlock value: (self at: idx)	].</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompInitialize">stompInitialize	"override if you like"	</body><body package="Stomp-Core" selector="stompInstVarAt:named:put:">stompInstVarAt: instVarIndex named: varName put: aValue 	instVarIndex = 0 ifTrue: [		^ StompPortableUtil default instVarNamed: varName put: aValue in: self	].	self instVarAt: instVarIndex put: aValue</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompInstVarNamed:writtenAs:">stompInstVarNamed: varName writtenAs: writtenValue	"override"	^ writtenValue</body><body package="Stomp-Core" selector="stompPrepareWrite">stompPrepareWrite</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompReadContentFrom:">stompReadContentFrom: stompReader 	"override"	^self stompBasicReadContentFrom: stompReader 	</body><body package="Stomp-Core" selector="stompReadValue">stompReadValue	"override if you like"	^self</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^true	</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	"override"	^true	</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	"override"	^#()</body><body package="Stomp-Core" selector="stompTypeName">stompTypeName	^ self class name </body><body package="Stomp-Core" selector="stompValueContentSize">stompValueContentSize	"For Mixed class which would like to write instance variables"	((self stompShouldWriteInstanceVariables			and: [self class isVariable])			and: [self class instSize &gt; 0])		ifTrue: [^ 3].	^ 1</body><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter 	"Override as you wish"	"Provides basic dispatch to stompWriter"	| cls |	cls := self class.	cls isBits ifTrue: [^ stompWriter writeBitsOf: self].	cls isVariable ifTrue: [^ stompWriter writeMixedFieldsOf: self].	^ stompWriter writeInstVarsOf: self</body><body package="Stomp-Core" selector="stompWriteValue">stompWriteValue	^self</body><body package="Stomp-Core" selector="toStomp">toStomp	^ StompWriter encode: self</body></methods><methods><class-id>Core.String</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Metaclass</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstance">stompCreateInstance	^ StompPortableUtil default soleInstanceOf: self</body></methods><methods><class-id>Core.Collection class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateCollectionInstanceFrom:">stompCreateCollectionInstanceFrom: stompReader	^self stompCreateMixedInstanceFrom: stompReader</body><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| cls |	stompReader context clearFieldsInfo.	cls := self.	cls isBits ifTrue: [^ self stompCreateBitsInstanceFrom: stompReader].	^ self stompCreateCollectionInstanceFrom: stompReader				</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompAdd:at:">stompAdd: elem at: idx	"override"	self add: elem</body><body package="Stomp-Core" selector="stompDo:">stompDo: aBlock	"override"	self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompReadContentFrom:">stompReadContentFrom: stompReader 	| fieldsInfo |	fieldsInfo := stompReader context fieldsInfo.	fieldsInfo isNil ifTrue: [^self].	fieldsInfo isPureIndexFields ifTrue: [ ^ stompReader readCollectionFieldsInto: self sized: fieldsInfo indexFieldSize].	fieldsInfo isMixedFields ifTrue: [		self stompShouldWriteInstanceVariables ifTrue: [stompReader readInstVarsInto: self].		stompReader readCollectionFieldsInto: self.	].		^self</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	"override"	"Usually Collection's inst vars are not needed for serialization"	^false	</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter 	"Override as you wish"	"Provides basic dispatch to stompWriter"	| cls |	cls := self class.	cls isBits ifTrue: [^ stompWriter writeBitsOf: self].	^ stompWriter writeMixedFieldsOf: self</body></methods><methods><class-id>Core.Duration class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default durationFromNanoseconds: stompReader readObject</body></methods><methods><class-id>Core.Duration</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default nanosecondsFromDuration: self)</body></methods><methods><class-id>Core.Character class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default characterFromUnicode: stompReader readObject</body></methods><methods><class-id>Core.Character</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default unicodeFromCharacter: self)</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompLoadContentsOnCreation">stompLoadContentsOnCreation	"override"	self isBits ifTrue: [^true]. 	^ self class includesSelector: #stompCreateInstanceFrom: "Typically"	</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	^Object class allInstVarNames</body></methods><methods><class-id>Core.Symbol class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ (super stompCreateInstanceFrom: stompReader) asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>*Stomp-Core</category><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Number</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false	</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="fromStomp:">fromStomp: bytes	^ StompReader decode: bytes</body><body package="Stomp-Core" selector="fromStomp:setting:">fromStomp: bytes setting: aBlock	| context reader |	reader := StompReader new.	context := reader context.	aBlock value: context.	^reader decode: bytes.</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation-helper</category><body package="Stomp-Core" selector="stompCreateBitsInstanceFrom:">stompCreateBitsInstanceFrom: stompReader	^stompReader readBitsOf: self</body><body package="Stomp-Core" selector="stompCreateFixedInstanceFrom:">stompCreateFixedInstanceFrom: stompReader	^self stompCreateInstance</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstance">stompCreateInstance	^[self new]		on: Error		do: [:ex | 			| alterClass | 			alterClass := StompNewFailed signal: self name.			alterClass isNil				ifTrue: [self basicNew]				ifFalse: [alterClass basicNew]]</body><body package="Stomp-Core" selector="stompCreateInstance:">stompCreateInstance: size	^ [self new: size]		on: Error		do: [:ex | 			| alterClass | 			alterClass := StompNewFailed signal: self name.			alterClass isNil				ifTrue: [[self basicNew: size] on: Error do: [self stompCreateInstance]]				ifFalse: [alterClass basicNew: size]]</body><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| cls |	stompReader context clearFieldsInfo.	cls := self.	cls isBits ifTrue: [^ self stompCreateBitsInstanceFrom: stompReader].	cls isVariable		ifTrue: [^ self stompCreateMixedInstanceFrom: stompReader].			^ self stompCreateFixedInstanceFrom: stompReader</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation-helper</category><body package="Stomp-Core" selector="stompCreateMixedInstanceFrom:">stompCreateMixedInstanceFrom: stompReader	| type size indexFieldSize  |	type := stompReader readType. 	size := stompReader readSizeOfArrayIfMatched: type.	size = 0 ifTrue: [^ self stompCreateInstance].	size &gt;= 1 ifTrue: [		stompReader context fieldsInfo: (StompFieldsInfo pureIndexFieldsSized: size).		^ self stompCreateInstance: size. 	].	"Otherwise, mixed fields"	indexFieldSize := stompReader readUIntIfMatched: type.	stompReader context fieldsInfo: (StompFieldsInfo mixedFields).	^ self stompCreateInstance: indexFieldSize</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	"For bits object"	"override - if nessesary"	^StompPortableUtil default bytes: rawBytes intoOf: self. 	</body></methods><methods><class-id>Core.Boolean</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*Stomp-Core</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.Time class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^self fromSeconds: stompReader readObject</body></methods><methods><class-id>Core.Time</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Time</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: self asSeconds</body></methods><methods><class-id>Core.Point class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rectArray |	rectArray := stompReader readPrimitiveValues.	^ (rectArray at: 1) @ (rectArray at: 2)</body></methods><methods><class-id>Core.Point</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rectArray |	rectArray := Array with: self x with: self y.	stompWriter writePrimitiveValues: rectArray</body></methods><methods><class-id>Kernel.BlockClosure class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	StompInvalidDeserialization signal: stompReader readObject.	^nil</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	StompInvalidSerialization signal: self class name.	stompWriter writeObject: self printString</body></methods><methods><class-id>Core.Text</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompAdd:at:">stompAdd: elem at: idx	self at: idx put: elem</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rectArray |	rectArray := stompReader readPrimitiveValues.	^ (rectArray at: 1) @ (rectArray at: 2) corner: (rectArray at: 3) @ (rectArray at: 4)</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rectArray |	rectArray := Array with: self origin x with: self origin y with: self corner x with: self corner y.	stompWriter writePrimitiveValues: rectArray</body></methods><methods><class-id>Core.IdentityDictionary class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| dic inst |	dic := stompReader readObject.	inst := self new.	dic keysAndValuesDo: [:k :v | inst at: k put: v].		^ inst</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeMap: self.		</body></methods><methods><class-id>Core.Date class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default dateFromSeconds: stompReader readObject</body></methods><methods><class-id>Core.Date</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Date</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: self asSeconds</body></methods><methods><class-id>Core.RunArray class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| fraArray |	fraArray := stompReader readPrimitiveValues.	^self runs: (fraArray at: 1) values: (fraArray at: 2)</body></methods><methods><class-id>Core.RunArray</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: self runs with: self values)</body></methods><methods><class-id>Core.Interval class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| intervalArray |	intervalArray := stompReader readPrimitiveValues.	^self from: (intervalArray at: 1) to: (intervalArray at: 2) by: (intervalArray at: 3)</body></methods><methods><class-id>Core.Interval</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: start with: stop with: step)</body></methods><methods><class-id>Core.Fraction class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| fraArray |	fraArray := stompReader readPrimitiveValues.	^self numerator: (fraArray at: 1) denominator: (fraArray at: 2)</body></methods><methods><class-id>Core.Fraction</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: self numerator with: self denominator)</body></methods><initialize><class-id>StompPopularClassMap</class-id></initialize><initialize><class-id>StompPortableUtil</class-id></initialize><initialize><class-id>StompVwPortableUtil</class-id></initialize><initialize><class-id>StompConstants</class-id></initialize><initialize><class-id>StompWarning</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>totalNanoseconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>MpSettings</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>MpPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>UUID</name><environment>Smalltalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UUID</category><attributes><package>UUID</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MpEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>DwordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>MpDecoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>