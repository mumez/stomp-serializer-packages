<?xml version="1.0"?><st-source><!-- Name: StOMP-AllNotice: Copyright (C) 2011- Masashi UmezawaBundleName: StOMP-AllBundleStructure: a Store.BundleForParcelComment: ** StOMP - Smalltalk Objects on MessagePack**http://stomp.smalltalk-users.jp/Yet another multi-dialect object serializer built on MessagePack.The aim is to provide portable, fast, compact serializer for major Smalltalk dialects. StOMP is optimized for small/medium sized data. It is especially suitable for KVS or RPC.This bundle includes core runtime & test cases. Prerequisites: MessagePack-All (Bundle)Copyright (C) 2011- Masashi UmezawaDevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'UUID' '') #(#any 'MessagePack-All' ''))DisregardedPrerequisites: #()Parcel: #('StOMP-All')ParcelName: StOMP-AllPrerequisiteDescriptions: #(#(#name 'SUnitToo' #componentType #package) #(#name 'UUID' #componentType #package) #(#name 'MessagePack-All' #componentType #bundle))PrerequisiteParcels: #(#('SUnitToo' '') #('UUID' '') #('MessagePack-All' ''))Version: 1.8Date: 11:35:25 PM June 17, 2011 --><time-stamp>From VisualWorks® NonCommercial, 7.7.1 of 2010年7月26日 on 2011年6月17日 at 23:35:25</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StompTestCase</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompWriterTestCase</name><environment>Smalltalk</environment><super>StompTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><comment><class-id>StompWriterTestCase</class-id><body>self suite run</body></comment><class><name>StompMockRequest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockFixedClass2</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instVar1 instVar2 instVar3 instVar4 instVar5 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompContext</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestor objectsDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompWriteContext</name><environment>Smalltalk</environment><super>StompContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classesDictionary environmentsDictionary instVarNamesWithIndicesDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompNewFailedTestCase</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompVwPortableUtil</name><environment>Smalltalk</environment><super>StompPortableUtil</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Squeak-Core</category><attributes><package>Stomp-VW-Core</package></attributes></class><class><name>StompWarning</name><environment>Smalltalk</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className element context </inst-vars><class-inst-vars>suppressTranscriptLogging suppressSignaling </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompNewFailed</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompSettings</name><environment>Smalltalk</environment><super>MpSettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompVwTestCase</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-VW-Core</category><attributes><package>StompTest-VW-Core</package></attributes></class><class><name>StompClassNotFound</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompMockCustomWriteObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name email </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompReaderTestCase</name><environment>Smalltalk</environment><super>StompTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockVariableClass</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockFixedClass</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instVar1 instVar2 instVar3 instVar4 instVar5 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockObjectInitializingOnRead</name><environment>Smalltalk</environment><super>StompMockFixedClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockFixedNewFailedClass</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>att1 att2 att3Block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockFixedAlternativeClass</name><environment>Smalltalk</environment><super>StompMockFixedNewFailedClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockShapeChangedObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>renamedAtt1 addedAtt1 originalAtt1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompFieldsInfo</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type indexFieldSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompPortableFixtures</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockPerson</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name requests partners </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompShapeChanger</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompConstants</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>tupleTags </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompInvalidDeserialization</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompReadContext</name><environment>Smalltalk</environment><super>StompContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classIdsDictionary environmentNamesDictionary instVarNamesWithIndicesDictionary classAliasesDictionary shapeChangersDictionary fieldsInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompMockObjectPreparingOnWrite</name><environment>Smalltalk</environment><super>StompMockFixedClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompWriter</name><environment>Smalltalk</environment><super>MpEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompMockVariableNewFailedClass</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>att1 att2 att3Block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockVariableAlternativeClass</name><environment>Smalltalk</environment><super>StompMockVariableNewFailedClass</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompCustomSerializationTestCase</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockShapeChanger</name><environment>Smalltalk</environment><super>StompShapeChanger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockMementoArray</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompPopularClassMap</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classToCode codeToClass </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompMockPersonShapeChanger</name><environment>Smalltalk</environment><super>StompShapeChanger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompShapeChangerTestCase</name><environment>Smalltalk</environment><super>StompTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompVwFixtures</name><environment>Smalltalk</environment><super>StompPortableFixtures</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Squeak-Core</category><attributes><package>StompTest-VW-Core</package></attributes></class><class><name>StompVwPopularClassMap</name><environment>Smalltalk</environment><super>StompPopularClassMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Squeak-Core</category><attributes><package>Stomp-VW-Core</package></attributes></class><class><name>StompInvalidSerialization</name><environment>Smalltalk</environment><super>StompWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompReader</name><environment>Smalltalk</environment><super>MpDecoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompMockObjectWithCache</name><environment>Smalltalk</environment><super>StompMockFixedClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>att1 att2 cache1 </class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompBlockShapeChanger</name><environment>Smalltalk</environment><super>StompShapeChanger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadInstVarsBlock loadAdditionsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Stomp-Core</category><attributes><package>Stomp-Core</package></attributes></class><class><name>StompReadWriteTestCase</name><environment>Smalltalk</environment><super>StompTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockByteArray</name><environment>Smalltalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockShapeChangerForRenamedComplexRead</name><environment>Smalltalk</environment><super>StompShapeChanger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><class><name>StompMockMixedClass</name><environment>Smalltalk</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>instVar1 instVar2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StompTest-Core</category><attributes><package>StompTest-Core</package></attributes></class><shared-variable><name>Default</name><environment>StompPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Stomp-Core</package></attributes></shared-variable><shared-variable><name>DialectSpecificClass</name><environment>StompPortableUtil</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Stomp-Core</package></attributes></shared-variable><methods><class-id>StompTestCase</class-id> <category>fixtures</category><body package="StompTest-Core" selector="bagAnswerBytes">bagAnswerBytes	^#[147 161 2 225 148 30 30 20 10]</body><body package="StompTest-Core" selector="basicArrayAnswerBytes">basicArrayAnswerBytes	^#[148 1 2 3 147 146 161 4 165 72 101 108 108 111 2 3]</body><body package="StompTest-Core" selector="basicBitsClassAnswerBytes">basicBitsClassAnswerBytes	^#[147 161 2 129 17 218 0 18 83 116 111 109 112 77 111 99 107 66 121 116 101 65 114 114 97 121 163 0 127 255]</body><body package="StompTest-Core" selector="basicFixedClassAnswerBytes">basicFixedClassAnswerBytes	^#[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 116 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 164 70 73 86 69]</body><body package="StompTest-Core" selector="basicMixedClassAnswerBytes">basicMixedClassAnswerBytes	^#[149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102]</body><body package="StompTest-Core" selector="basicVariableClassAnswerBytes">basicVariableClassAnswerBytes	^#[147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102]</body><body package="StompTest-Core" selector="circularRefrencesAnswerBytes">circularRefrencesAnswerBytes	^#[148 147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 146 161 3 1 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 161 3 1 146 161 3 2 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 146 161 3 1 146 161 3 2]</body><body package="StompTest-Core" selector="classAnswerBytes">classAnswerBytes	^#[147 161 2 129 17 218 0 25 83 116 111 109 112 77 111 99 107 79 98 106 101 99 116 87 105 116 104 67 97 99 104 101 36 129 146 164 97 116 116 49 164 97 116 116 50 146 11 22]</body><body package="StompTest-Core" selector="classNameAndIdsAnswerBytes">classNameAndIdsAnswerBytes	^#[148 147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 111 110 101 192 192 192 147 161 2 0 150 0 2 146 161 5 163 116 119 111 192 192 192 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 3 146 161 5 165 116 104 114 101 101 144 149 161 2 1 0 147 1 4 146 161 5 164 102 111 117 114 144]</body><body package="StompTest-Core" selector="classNameAndIdsSuppressNilWritesAnswerBytes">classNameAndIdsSuppressNilWritesAnswerBytes	^#[148 147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 1 146 161 5 163 111 110 101 147 161 2 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 2 146 161 5 163 116 119 111 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 3 146 161 5 165 116 104 114 101 101 144 149 161 2 1 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 4 146 161 5 164 102 111 117 114 144]</body><body package="StompTest-Core" selector="colorAnswerBytes1">colorAnswerBytes1	^#[147 161 2 228 147 203 0 0 0 0 0 0 0 0 203 0 0 0 0 0 0 0 0 203 63 240 0 0 0 0 0 0]</body><body package="StompTest-Core" selector="colorAnswerBytes2">colorAnswerBytes2	^#[147 161 2 228 147 203 63 240 0 0 0 0 0 0 203 63 240 0 0 0 0 0 0 203 0 0 0 0 0 0 0 0]</body><body package="StompTest-Core" selector="compositeDictionaryAnswerBytes">compositeDictionaryAnswerBytes	^#[132 146 161 5 167 112 97 114 101 110 116 52 129 146 161 5 166 99 104 105 108 100 49 146 161 4 165 97 98 99 100 101 146 161 5 167 112 97 114 101 110 116 50 100 146 161 5 167 112 97 114 101 110 116 51 147 10 20 30 146 161 5 167 112 97 114 101 110 116 49 146 161 4 174 115 97 109 112 108 101 32 115 116 114 105 110 103 46]</body><body package="StompTest-Core" selector="dateAnswerBytes">dateAnswerBytes	^#[147 161 2 230 206 190 169 158 128]</body><body package="StompTest-Core" selector="dictionaryAnswerBytes">dictionaryAnswerBytes	^#[131 146 161 5 164 107 101 121 51 146 161 4 166 118 97 108 117 101 51 146 161 5 164 107 101 121 49 146 161 4 166 118 97 108 117 101 49 146 161 5 164 107 101 121 50 146 161 4 166 118 97 108 117 101 50]</body><body package="StompTest-Core" selector="durationAnswerBytes">durationAnswerBytes	^ #[147 161 2 241 207 0 0 0 28 163 95 14 0]</body><body package="StompTest-Core" selector="fixedClassWithNilValuesAnswerBytes">fixedClassWithNilValuesAnswerBytes	^#[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 147 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 53 147 1 203 64 10 102 102 102 102 102 102 146 161 4 164 70 73 86 69]</body><body package="StompTest-Core" selector="floatingPointAnswerBytes1">floatingPointAnswerBytes1	^ StompPortableUtil default testFixturesClass float1dot2bytes</body><body package="StompTest-Core" selector="floatingPointAnswerBytes2">floatingPointAnswerBytes2	"double"	^#[203 65 210 101 128 180 135 230 183]</body><body package="StompTest-Core" selector="fractionAnswerBytes">fractionAnswerBytes	^#[147 161 2 231 146 3 4]</body><body package="StompTest-Core" selector="intervalAnswerBytes">intervalAnswerBytes	^#[147 161 2 234 147 1 10 3]</body><body package="StompTest-Core" selector="mixedClassNoVariableDataAnswerBytes">mixedClassNoVariableDataAnswerBytes	^#[149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 0 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 144]</body><body package="StompTest-Core" selector="ordredCollectionAnswerBytes">ordredCollectionAnswerBytes	^#[147 161 2 235 147 10 20 30]</body><body package="StompTest-Core" selector="rectangleAnswerBytes">rectangleAnswerBytes	^#[147 161 2 237 148 1 1 3 4]</body><body package="StompTest-Core" selector="recursiveArrayAnswerBytes">recursiveArrayAnswerBytes	^#[147 10 20 146 161 3 0]</body><body package="StompTest-Core" selector="runArrayAnswerBytes">runArrayAnswerBytes	^#[147 161 2 244 146 147 1 2 1 147 1 2 3]</body><body package="StompTest-Core" selector="setAnswerBytes">setAnswerBytes	^#[147 161 2 238 147 10 20 30]</body><body package="StompTest-Core" selector="sharedReferenceAnswerBytes">sharedReferenceAnswerBytes	^#[148 147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 86 97 114 105 97 98 108 101 67 108 97 115 115 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 3 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 146 195 194 146 192 144 147 1 146 161 4 163 116 119 111 203 64 10 102 102 102 102 102 102 146 161 3 1 146 161 3 2]</body><body package="StompTest-Core" selector="stringAnswerBytes">stringAnswerBytes	^#[146 161 4 218 0 21 72 105 44 32 73 39 109 32 83 116 114 105 110 103 45 111 98 106 101 99 116]</body><body package="StompTest-Core" selector="symbolAnswerBytes">symbolAnswerBytes	^#[146 161 5 167 97 98 99 100 101 102 103]</body><body package="StompTest-Core" selector="timeAnswerBytes">timeAnswerBytes	^#[147 161 2 242 206 0 1 72 104]</body><body package="StompTest-Core" selector="timestampAnswerBytes">timestampAnswerBytes	^#[147 161 2 243 207 46 57 36 122 10 159 20 0]</body></methods><methods><class-id>StompWriterTestCase</class-id> <category>tests</category><body package="StompTest-Core" selector="testWriteBag">testWriteBag	"self debug: #testWriteBag"	| bag actual expected |	bag := Bag new.	bag add: 10.	bag add: 20.	bag add: 30.	bag add: 30.	expected := self bagAnswerBytes.		actual := bag toStomp.		self should: [actual size = 9].	self should: [(actual copyFrom: 1 to: 5) = (expected copyFrom: 1 to: 5)].	self should: [(actual copyFrom: 6 to: 9) asSortedCollection = (expected copyFrom: 6 to: 9) asSortedCollection]</body><body package="StompTest-Core" selector="testWriteBasicArray">testWriteBasicArray	"self debug: #testWriteBasicArray"	| data wstr bytes |	data := #(1 2 3 #('Hello' 2 3)).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicArrayAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteBasicBitsClass">testWriteBasicBitsClass	"self debug: #testWriteBasicBitsClass"	| data wstr bytes |	data := StompMockByteArray new: 3.	data at: 1 put: 0.	data at: 2 put: 127.	data at: 3 put: 255.	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicBitsClassAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteBasicFixedClass">testWriteBasicFixedClass	"self debug: #testWriteBasicFixedClass"	| data wstr bytes |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: #two.	data instVar3: 3.3d.	data instVar4: false.	data instVar5: 'FIVE'.	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicFixedClassAnswerBytes]</body><body package="StompTest-Core" selector="testWriteBasicMixedClass">testWriteBasicMixedClass	"self debug: #testWriteBasicMixedClass"	| data wstr bytes |	data := StompMockMixedClass new: 3.	data at: 1 put: 1.	data at: 2 put: 'two'.	data at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	data instVar1: #(true false).	data instVar2: #(nil #()).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicMixedClassAnswerBytes]</body><body package="StompTest-Core" selector="testWriteBasicVariableClass">testWriteBasicVariableClass	"self debug: #testWriteBasicVariableClass"	| data wstr bytes |	data := StompMockVariableClass new: 3.	data at: 1 put: 1.	data at: 2 put: 'two'.	data at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self basicVariableClassAnswerBytes]</body><body package="StompTest-Core" selector="testWriteBoolean">testWriteBoolean	"self debug: #testWriteBoolean"	self should: [true toStomp =  #[195]].	self should: [false toStomp =  #[194]]				</body><body package="StompTest-Core" selector="testWriteByteArray">testWriteByteArray	"self debug: #testWriteByteArray"	| byteArray |	byteArray := (ByteArray with: 10 with: 20 with: 30).	self should: [byteArray toStomp = #[163 10 20 30]].			</body><body package="StompTest-Core" selector="testWriteCharacter">testWriteCharacter	"self debug: #testWriteCharacter"	| char1 char2 |	char1 := $A.		self should: [char1 toStomp =  #[147 161 2 227 65]].	char2 := (StompPortableUtil default characterFromUnicode: 12354). "Japanese Hiragana 'A' "		self should: [char2 toStomp =  #[147 161 2 227 205 48 66]].			</body><body package="StompTest-Core" selector="testWriteCircularRefrences1">testWriteCircularRefrences1	"self debug: #testWriteCircularRefrences1"	| inst1 inst2 data wstr bytes |	inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: inst1.		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: inst1.	inst2 instVar2: inst2.		data := Array with: inst1 with: inst2 with: inst1 with: inst2.		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.	self should: [bytes = self circularRefrencesAnswerBytes]</body><body package="StompTest-Core" selector="testWriteClass">testWriteClass	"self debug: #testWriteClass"	| cls bytes |	cls := StompMockObjectWithCache.	cls att1: 11.	cls att2: 22.	bytes := cls toStomp.	self should: [bytes = self classAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteClassNameAndIds">testWriteClassNameAndIds	"self debug: #testWriteClassNameAndIds"	| data1 data2 data3 data4 wstr bytes  data |	data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		data := Array with: data1 with: data2 with: data3 with: data4.		wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: false.	wstr nextPut: data.	bytes := wstr contents. 			self should: [bytes = self classNameAndIdsAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteClassNameAndIdsSuppressNilWrites">testWriteClassNameAndIdsSuppressNilWrites	"self debug: #testWriteClassNameAndIdsSuppressNilWrites"	| data1 data2 data3 data4 wstr bytes  data |	data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		data := Array with: data1 with: data2 with: data3 with: data4.		wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: true.	wstr nextPut: data.	bytes := wstr contents. 			self should: [bytes = self classNameAndIdsSuppressNilWritesAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteColor">testWriteColor	"self debug: #testWriteColor"	| color1 bytes1 color2 bytes2 |	color1 := StompPortableUtil default testFixturesClass blueColor.	bytes1 := color1 toStomp.	self should: [bytes1 = self colorAnswerBytes1].		color2 := StompPortableUtil default testFixturesClass yellowColor.	bytes2 := color2 toStomp.	self should: [bytes2 = self colorAnswerBytes2]				</body><body package="StompTest-Core" selector="testWriteCompositeDictionary">testWriteCompositeDictionary	"self debug: #testWriteCompositeDictionary"	| childDic dic bytes rawDic rawChildDic |	childDic := Dictionary new.	childDic at: #child1 put: 'abcde'.	dic := Dictionary new.	dic at: #parent1 put: 'sample string.'.	dic at: #parent2 put: 100.	dic at: #parent3 put: #(10 20 30 ).	dic at: #parent4 put: childDic.	bytes := dic toStomp.	rawDic := Object fromMessagePack: bytes.	self should: [rawDic size = 4].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 49])) = #(#[4] #[115 97 109 112 108 101 32 115 116 114 105 110 103 46])].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 50])) = 100].	self should: [(rawDic at: #(#[5] #[112 97 114 101 110 116 51])) = #(10 20 30)].	rawChildDic := rawDic at: #(#[5] #[112 97 114 101 110 116 52]).	self should: [(rawChildDic at: #(#[5] #[99 104 105 108 100 49])) = #(#[4] #[97 98 99 100 101])].	</body><body package="StompTest-Core" selector="testWriteDate">testWriteDate	"self debug: #testWriteDate"	| date bytes |	date := Date fromDays: 37023.	bytes := date toStomp.	self should: [bytes = self dateAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteDictionary">testWriteDictionary	"self debug: #testWriteDictionary"	| dic bytes rawDic |	dic := Dictionary new.	dic at: #key1 put: 'value1'.	dic at: #key2 put: 'value2'.	dic at: #key3 put: 'value3'.		bytes := dic toStomp.	rawDic := Object fromMessagePack: bytes.	self should: [rawDic size = 3].	self should: [(rawDic at: #(#[5] #[107 101 121 49])) = #(#[4] #[118 97 108 117 101 49])].	self should: [(rawDic at: #(#[5] #[107 101 121 50])) = #(#[4] #[118 97 108 117 101 50])].	self should: [(rawDic at: #(#[5] #[107 101 121 51])) = #(#[4] #[118 97 108 117 101 51])].	</body><body package="StompTest-Core" selector="testWriteDuration">testWriteDuration	"self debug: #testWriteDuration"	| duration bytes |	duration := 123 seconds.	bytes := duration toStomp.	self should: [bytes = self durationAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteFixedClassWithNilValues">testWriteFixedClassWithNilValues	"self debug: #testWriteFixedClassWithNilValues"	| data wstr bytes |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: nil.	data instVar3: (StompPortableUtil default testFixturesClass double3dot3).	data instVar4: nil.	data instVar5: 'FIVE'.	wstr := StompWriter onBytes: ByteArray new.	wstr settings suppressNilWrite: true.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self fixedClassWithNilValuesAnswerBytes]</body><body package="StompTest-Core" selector="testWriteFraction">testWriteFraction	"self debug: #testWriteFraction"	| fra bytes |	fra := 3 / 4.		bytes := fra toStomp.	self should: [bytes = self fractionAnswerBytes]	</body><body package="StompTest-Core" selector="testWriteInterval">testWriteInterval	"self debug: #testWriteInterval"	| interval bytes |	interval := 1 to: 10 by: 3.		bytes := interval toStomp.	self should: [bytes = self intervalAnswerBytes]	</body><body package="StompTest-Core" selector="testWriteMixedClassNoVariableData">testWriteMixedClassNoVariableData	"self debug: #testWriteMixedClassNoVariableData"	| data wstr bytes |	data := StompMockMixedClass new.	data instVar1: #(true false).	data instVar2: #(nil #()).	wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.		self should: [bytes = self mixedClassNoVariableDataAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteNumber">testWriteNumber	"self debug: #testWriteNumber"	self should: [1 toStomp = #[1]].	self should: [1.2 toStomp = self floatingPointAnswerBytes1].	self should: [StompPortableUtil default testFixturesClass double1234567890dot123456789 toStomp = self floatingPointAnswerBytes2]</body><body package="StompTest-Core" selector="testWriteOrdredCollection">testWriteOrdredCollection	"self debug: #testWriteOrdredCollection"	| ord bytes |	ord := OrderedCollection new.	ord add: 10.	ord add: 20.	ord add: 30.	bytes := ord toStomp.	self should: [bytes =  self ordredCollectionAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteRectangle">testWriteRectangle	"self debug: #testWriteRectangle"	| rect bytes |	rect := (1@1 corner: 3@4).		bytes := rect toStomp.	self should: [bytes = self rectangleAnswerBytes]	</body><body package="StompTest-Core" selector="testWriteRecursiveArray">testWriteRecursiveArray	"self debug: #testWriteRecursiveArray"	| arr bytes |	arr := Array new: 3.	arr at: 1 put: 10.	arr at: 2 put: 20.	arr at: 3 put: arr.	bytes := arr toStomp.	self should: [bytes = self recursiveArrayAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteRunArray">testWriteRunArray	"self debug: #testWriteRunArray"	| arr bytes |	arr := RunArray runs: #(1 2 1) values: #(1 2 3).	bytes := arr toStomp.	self should: [bytes = self runArrayAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteSet">testWriteSet	"self debug: #testWriteSet"	| set expected actual |	set := Set new.	set add: 10.	set add: 20.	set add: 30.	set add: 30.	expected := self setAnswerBytes.		actual := set toStomp.		self should: [actual size = 8].	self should: [(actual copyFrom: 1 to: 5) = (expected copyFrom: 1 to: 5)].	self should: [(actual copyFrom: 6 to: 8) asSortedCollection = (expected copyFrom: 6 to: 8) asSortedCollection]		</body><body package="StompTest-Core" selector="testWriteSharedRefrences1">testWriteSharedRefrences1	"self debug: #testWriteSharedRefrences1"	| inst1 inst2 data wstr bytes |	inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: #(true false).	inst2 instVar2: #(nil #()).		data := Array with: inst1 with: inst2 with: inst1 with: inst2.		wstr := StompWriter onBytes: ByteArray new.	wstr nextPut: data.	bytes := wstr contents.	self should: [bytes = self sharedReferenceAnswerBytes]</body><body package="StompTest-Core" selector="testWriteString">testWriteString	"self debug: #testWriteString"	| str1 |	str1 := 'Hi, I''m String-object'.	self should: [str1 toStomp = self stringAnswerBytes].				</body><body package="StompTest-Core" selector="testWriteSymbol">testWriteSymbol	"self debug: #testWriteSymbol"	| symbol1 |	symbol1 := #abcdefg.	self should: [symbol1 toStomp = self symbolAnswerBytes].				</body><body package="StompTest-Core" selector="testWriteTime">testWriteTime	"self debug: #testWriteTime"	| inst bytes |	inst := Time fromSeconds: 84072.	bytes := inst toStomp.	self should: [bytes = self timeAnswerBytes]				</body><body package="StompTest-Core" selector="testWriteTimestamp">testWriteTimestamp	"self debug: #testWriteTimestamp"	| bytes timestamp |	timestamp := StompPortableUtil default testFixturesClass timestamp1.	bytes := timestamp toStomp.	self should: [bytes = self timestampAnswerBytes]	</body><body package="StompTest-Core" selector="testWriteUndefinedObject">testWriteUndefinedObject	"self debug: #testWriteUndefinedObject"	self should: [nil toStomp = #[192]].		</body></methods><methods><class-id>StompMockRequest</class-id> <category>accessing</category><body package="StompTest-Core" selector="id">id	^ id</body><body package="StompTest-Core" selector="id:">id: anObject	id := anObject</body><body package="StompTest-Core" selector="owner">owner	^ owner</body><body package="StompTest-Core" selector="owner:">owner: anObject	owner := anObject</body></methods><methods><class-id>StompMockFixedClass2</class-id> <category>accessing</category><body package="StompTest-Core" selector="instVar1">instVar1	"Answer the value of instVar1"	^ instVar1</body><body package="StompTest-Core" selector="instVar1:">instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject</body><body package="StompTest-Core" selector="instVar2">instVar2	"Answer the value of instVar2"	^ instVar2</body><body package="StompTest-Core" selector="instVar2:">instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject</body><body package="StompTest-Core" selector="instVar3">instVar3	"Answer the value of instVar3"	^ instVar3</body><body package="StompTest-Core" selector="instVar3:">instVar3: anObject	"Set the value of instVar3"	instVar3 := anObject</body><body package="StompTest-Core" selector="instVar4">instVar4	"Answer the value of instVar4"	^ instVar4</body><body package="StompTest-Core" selector="instVar4:">instVar4: anObject	"Set the value of instVar4"	instVar4 := anObject</body><body package="StompTest-Core" selector="instVar5">instVar5	"Answer the value of instVar5"	^ instVar5</body><body package="StompTest-Core" selector="instVar5:">instVar5: anObject	"Set the value of instVar5"	instVar5 := anObject</body></methods><methods><class-id>StompMockFixedClass2</class-id> <category>comparing</category><body package="StompTest-Core" selector="equals:">equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	instVar3 = other instVar3 ifFalse: [^false].	instVar4 = other instVar4 ifFalse: [^false].	instVar5 = other instVar5 ifFalse: [^false].	^true</body></methods><methods><class-id>StompContext</class-id> <category>actions</category><body package="Stomp-Core" selector="at:">at: key	^self objectsDictionary at: key</body><body package="Stomp-Core" selector="at:ifAbsent:">at: key ifAbsent: block	^self objectsDictionary at: key ifAbsent: block</body><body package="Stomp-Core" selector="at:ifAbsentPut:">at: key ifAbsentPut: value	^self objectsDictionary at: key ifAbsentPut: value</body><body package="Stomp-Core" selector="at:put:">at: key put: value	^self objectsDictionary at: key put: value</body><body package="Stomp-Core" selector="includesKey:">includesKey: key 	^self objectsDictionary includesKey: key</body><body package="Stomp-Core" selector="keys">keys	^self objectsDictionary keys</body><body package="Stomp-Core" selector="keysAndValuesDo:">keysAndValuesDo: block	^self objectsDictionary keysAndValuesDo: block</body><body package="Stomp-Core" selector="removeKey:">removeKey: key 	^self objectsDictionary removeKey: key</body><body package="Stomp-Core" selector="removeKey:ifAbsent:">removeKey: key ifAbsent: block	^self objectsDictionary removeKey: key ifAbsent: block</body><body package="Stomp-Core" selector="size">size	^self objectsDictionary size</body><body package="Stomp-Core" selector="values">values	^self objectsDictionary values</body></methods><methods><class-id>StompContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="objectsDictionary">objectsDictionary	"Answer the value of objectsDictionary"	^ objectsDictionary ifNil: [objectsDictionary := self objectDictionaryClass new]</body><body package="Stomp-Core" selector="objectsDictionary:">objectsDictionary: anObject	"Set the value of objectsDictionary"	objectsDictionary := anObject</body><body package="Stomp-Core" selector="requestor">requestor	^ requestor</body><body package="Stomp-Core" selector="requestor:">requestor: anObject	"Set the value of requestor"	requestor := anObject</body><body package="Stomp-Core" selector="settings">settings	^self requestor settings</body></methods><methods><class-id>StompContext</class-id> <category>defaults</category><body package="Stomp-Core" selector="objectDictionaryClass">objectDictionaryClass	^IdentityDictionary</body></methods><methods><class-id>StompContext</class-id> <category>printing</category><body package="Stomp-Core" selector="printOn:">printOn: aStream	aStream nextPutAll: self class name.	aStream nextPutAll: '('.	aStream cr.	self objectsDictionary associationsDo: [:assoc |		assoc printOn: aStream.		aStream cr.	].	aStream nextPutAll: ')'.</body></methods><methods><class-id>StompContext class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="on:">on: requestor 	^ self new requestor: requestor;		 yourself</body></methods><methods><class-id>StompWriteContext</class-id> <category>actions</category><body package="Stomp-Core" selector="classIdOf:">classIdOf: aClass	^ self classesDictionary at: aClass</body><body package="Stomp-Core" selector="environmentIdOf:">environmentIdOf: aClass	^ self environmentsDictionary at: aClass</body><body package="Stomp-Core" selector="includesClass:">includesClass: aClass	^ self classesDictionary includesKey: aClass</body><body package="Stomp-Core" selector="includesEnvironment:">includesEnvironment: anEnvironment	self settings useEnvironment ifFalse: [^false].	^ self environmentsDictionary includesKey: anEnvironment</body><body package="Stomp-Core" selector="instVarNamesWithIndicesOf:">instVarNamesWithIndicesOf: aClass	^ self instVarNamesWithIndicesDictionary at: aClass ifAbsent: []</body><body package="Stomp-Core" selector="rememberClass:">rememberClass: aClass	^ self classesDictionary at: aClass put: (self classesDictionary size)</body><body package="Stomp-Core" selector="rememberEnvironment:">rememberEnvironment: anEnvironment	self settings useEnvironment ifFalse: [^self].	anEnvironment name == #Smalltalk ifTrue: [^self].	^ self environmentsDictionary at: anEnvironment put: (self environmentsDictionary size)</body><body package="Stomp-Core" selector="rememberInstVarNames:indices:of:">rememberInstVarNames: instVarNames indices: instVarIndices of: aClass	| ord |	ord := OrderedCollection new: instVarNames size.	instVarNames with: instVarIndices do: [:name :idx | ord add: (Array with: name with: idx)]. 	self instVarNamesWithIndicesDictionary at: aClass put: ord.	^ord</body><body package="Stomp-Core" selector="rememberReferenceOf:">rememberReferenceOf: originalObject	self at: originalObject put: self size.</body></methods><methods><class-id>StompWriteContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="classesDictionary">classesDictionary	^ classesDictionary ifNil: [classesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="classesDictionary:">classesDictionary: anObject	"Set the value of classesDictionary"	classesDictionary := anObject</body><body package="Stomp-Core" selector="environmentsDictionary">environmentsDictionary	^ environmentsDictionary ifNil: [environmentsDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="environmentsDictionary:">environmentsDictionary: anObject	"Set the value of environmentsDictionary"	environmentsDictionary := anObject</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary">instVarNamesWithIndicesDictionary	^ instVarNamesWithIndicesDictionary ifNil: [instVarNamesWithIndicesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary:">instVarNamesWithIndicesDictionary: anObject	"Set the value of instVarNamesWithIndicesDictionary"	instVarNamesWithIndicesDictionary := anObject</body></methods><methods><class-id>StompError class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:">signal: aString	| inst |	inst := self new.	inst messageText: aString.	^MpPortableUtil default signalException: inst</body></methods><methods><class-id>StompNewFailedTestCase</class-id> <category>tests</category><body package="StompTest-Core" selector="testWriteReadNewFailedClass">testWriteReadNewFailedClass	"self debug: #testWriteReadNewFailedClass"	| original stomp read |	original := StompMockFixedNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := Object fromStomp: stomp.	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				</body><body package="StompTest-Core" selector="testWriteReadNewFailedClassReceiverAlternative">testWriteReadNewFailedClassReceiverAlternative	"self debug: #testWriteReadNewFailedClassReceiverAlternative"	| original stomp read |	original := StompMockFixedNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := [Object fromStomp: stomp] on: StompNewFailed do: [:ex | ex resume: StompMockFixedAlternativeClass].	self should: [read class = StompMockFixedAlternativeClass].	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				</body><body package="StompTest-Core" selector="testWriteReadNewVariableFailedClass">testWriteReadNewVariableFailedClass	"self debug: #testWriteReadNewVariableFailedClass"	| original stomp read |	original := StompMockVariableNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := Object fromStomp: stomp.	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				</body><body package="StompTest-Core" selector="testWriteReadNewVariableFailedClassReciverAlternative">testWriteReadNewVariableFailedClassReciverAlternative	"self debug: #testWriteReadNewVariableFailedClassReciverAlternative"	| original stomp read |	original := StompMockVariableNewFailedClass prototype1.	self should: [original att1 = 1].	self should: [original att2 =  'TWO']. 	self should: [original toStomp] raise: StompInvalidSerialization.	stomp := original toStomp.		self should: [Object fromStomp: stomp] raise: StompNewFailed.	read := [Object fromStomp: stomp] on: StompNewFailed do: [:ex | ex resume: StompMockVariableAlternativeClass].	self should: [read class = StompMockVariableAlternativeClass].	self should: [read att1 = 1].	self should: [read att2 =  'TWO'].	self should: [read att3Block notNil].				</body></methods><methods><class-id>StompPortableUtil</class-id> <category>converting</category><body package="Stomp-Core" selector="bytesFromString:">bytesFromString: aString	^aString asByteArray</body><body package="Stomp-Core" selector="characterFromUnicode:">characterFromUnicode: anInteger	^Character value: anInteger</body><body package="Stomp-Core" selector="colorFromRgbArray:">colorFromRgbArray: rgbArray	^nil</body><body package="Stomp-Core" selector="dateAndTimeFromNanoseconds:">dateAndTimeFromNanoseconds: nanoseconds	^ self timestampFromNanoseconds: nanoseconds</body><body package="Stomp-Core" selector="dateFromSeconds:">dateFromSeconds: seconds	^ Date fromSeconds: seconds</body><body package="Stomp-Core" selector="durationFromNanoseconds:">durationFromNanoseconds: nanoseconds	"^Duration fromNanoseconds: nanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="nanosecondsFromDateAndTime:">nanosecondsFromDateAndTime: timestamp	"Answer the number of nanoseconds since January 1, 1901."	"^timestamp asNanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="nanosecondsFromDuration:">nanosecondsFromDuration: duration	self subclassResponsibility </body><body package="Stomp-Core" selector="stringFromBytes:">stringFromBytes: aByteArray	^aByteArray asString </body><body package="Stomp-Core" selector="timestampFromNanoseconds:">timestampFromNanoseconds: nanoseconds	"^ Timestamp fromNanoseconds: nanoseconds"	self subclassResponsibility </body><body package="Stomp-Core" selector="unicodeFromCharacter:">unicodeFromCharacter: aCharacter	^aCharacter asciiValue</body></methods><methods><class-id>StompPortableUtil</class-id> <category>actions</category><body package="Stomp-Core" selector="bytes:intoOf:">bytes: rawBytes intoOf: bitsClass	"override"	^bitsClass new: rawBytes size</body><body package="Stomp-Core" selector="bytesFrom:">bytesFrom: bitsObject	"override"	^bitsObject	</body><body package="Stomp-Core" selector="classNamed:">classNamed: localClassName	"override"	^ Smalltalk		at: localClassName		ifAbsent: []</body><body package="Stomp-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	"override"	| env |	environmentQualifier ifNil: [^ self classNamed: localClassName].					"Suppose namespace is not supported, so just use Smalltalk"	env :=  Smalltalk.	^ env		at: localClassName		ifAbsent: []</body><body package="Stomp-Core" selector="environmentNameOf:">environmentNameOf: anObject	^#Smalltalk</body><body package="Stomp-Core" selector="instVarIndexOf:for:">instVarIndexOf: aClass for: varName 	"override"	self subclassResponsibility.	^0</body><body package="Stomp-Core" selector="instVarIndicesOf:from:">instVarIndicesOf: aClass from: instVarNames	^ instVarNames collect: [:each |		self instVarIndexOf: aClass for: each	] </body><body package="Stomp-Core" selector="instVarNamed:put:in:">instVarNamed: varName put: value in: anObject	"Note that when varName is invalid, just silently ignore"	| index |	index := self instVarIndexOf: anObject class for: varName.	index = 0 ifTrue: [^self].	anObject instVarAt: index put: value			</body><body package="Stomp-Core" selector="nextAvailable:from:">nextAvailable: size from: stream	"even reached at end, just return contents as-is"	^stream nextAvailable: size</body><body package="Stomp-Core" selector="shouldWriteEnvironmentNameOf:">shouldWriteEnvironmentNameOf: anObject	^((self environmentNameOf: anObject) ~~ #Smalltalk)</body><body package="Stomp-Core" selector="soleInstanceOf:">soleInstanceOf: aMetaclass	^ aMetaclass soleInstance</body><body package="Stomp-Core" selector="useEnvironmentByDefault">useEnvironmentByDefault	^true</body></methods><methods><class-id>StompPortableUtil</class-id> <category>testing</category><body package="Stomp-Core" selector="isWideString:">isWideString: aString	"override"	^false</body><body package="Stomp-Core" selector="isWideSymbol:">isWideSymbol: aSymbol	"override"	^false</body></methods><methods><class-id>StompPortableUtil</class-id> <category>factory</category><body package="Stomp-Core" selector="encodeTypeMapperClass">encodeTypeMapperClass	^MpEncodeTypeMapper</body><body package="Stomp-Core" selector="popularClassMap">popularClassMap	"override"	^StompPopularClassMap default</body></methods><methods><class-id>StompPortableUtil</class-id> <category>*StompTest-Core-factory</category><body package="StompTest-Core" selector="testFixturesClass">testFixturesClass	self subclassResponsibility </body></methods><methods><class-id>StompPortableUtil class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	Default := nil.	DialectSpecificClass := nil</body></methods><methods><class-id>StompPortableUtil class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="default">default	^Default ifNil: [Default := self dialectSpecificClass new]</body></methods><methods><class-id>StompPortableUtil class</class-id> <category>factory</category><body package="Stomp-Core" selector="dialectSpecificClass">dialectSpecificClass	^DialectSpecificClass ifNil: [DialectSpecificClass := self subclasses at: 1]</body><body package="Stomp-Core" selector="dialectSpecificClass:">dialectSpecificClass: aClass	DialectSpecificClass := aClass</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>converting</category><body package="Stomp-VW-Core" selector="bytesFromString:">bytesFromString: aString	^aString asByteArrayEncoding: #utf8</body><body package="Stomp-VW-Core" selector="colorFromRgbArray:">colorFromRgbArray: rgbArray	^ColorValue		red: (rgbArray at: 1) asNumber		green: (rgbArray at: 2) asNumber		blue: (rgbArray at: 3) asNumber</body><body package="Stomp-VW-Core" selector="dateFromSeconds:">dateFromSeconds: seconds	^ (Timestamp fromSeconds: seconds) asDate</body><body package="Stomp-VW-Core" selector="durationFromNanoseconds:">durationFromNanoseconds: nanoseconds	^Duration fromNanoseconds: nanoseconds</body><body package="Stomp-VW-Core" selector="nanosecondsFromDateAndTime:">nanosecondsFromDateAndTime: timestamp	"Answer the number of nanoseconds since January 1, 1901."	^timestamp asNanoseconds</body><body package="Stomp-VW-Core" selector="nanosecondsFromDuration:">nanosecondsFromDuration: duration	^ duration asNanoseconds</body><body package="Stomp-VW-Core" selector="stringFromBytes:">stringFromBytes: aByteArray	^aByteArray asStringEncoding: #utf8</body><body package="Stomp-VW-Core" selector="timestampFromNanoseconds:">timestampFromNanoseconds: nanoseconds	^ Timestamp fromNanoseconds: nanoseconds</body><body package="Stomp-VW-Core" selector="unicodeFromCharacter:">unicodeFromCharacter: aCharacter	^aCharacter asInteger</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>actions</category><body package="Stomp-VW-Core" selector="bytes:intoOf:">bytes: rawBytes intoOf: bitsClass	^ rawBytes changeClassTo: bitsClass</body><body package="Stomp-VW-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	"override"	| bindingReference binding env |	environmentQualifier ifNil: [^ self classNamed: localClassName].	bindingReference := BindingReference pathString: environmentQualifier.	binding := bindingReference bindingOrNil ifNil: [^nil].	env :=  binding value.	^ env		at: localClassName		ifAbsent: []</body><body package="Stomp-VW-Core" selector="environmentNameOf:">environmentNameOf: anObject	^anObject class environment name</body><body package="Stomp-VW-Core" selector="instVarIndexOf:for:">instVarIndexOf: aClass for: varName 	^ aClass		instVarIndexFor: varName asString	</body><body package="Stomp-VW-Core" selector="instVarNamed:put:in:">instVarNamed: varName put: value in: anObject	"Note that when varName is invalid, just silently ignore"	| index |	index := anObject class						instVarIndexFor: varName asString.	index = 0 ifTrue: [^self].	anObject instVarAt: index put: value</body><body package="Stomp-VW-Core" selector="shouldWriteEnvironmentNameOf:">shouldWriteEnvironmentNameOf: anObject	| kls nonMeta |	kls := anObject class.	nonMeta := kls isMeta ifTrue: [kls soleInstance] ifFalse: [kls].	(Smalltalk at: nonMeta name ifAbsent: [^true]).	^false</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>factory</category><body package="Stomp-VW-Core" selector="popularClassMap">popularClassMap	"override"	^StompVwPopularClassMap default</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>testing</category><body package="Stomp-VW-Core" selector="isWideString:">isWideString: aString	^aString isByteIndexed not</body><body package="Stomp-VW-Core" selector="isWideSymbol:">isWideSymbol: aSymbol	^aSymbol isByteIndexed not</body></methods><methods><class-id>StompVwPortableUtil</class-id> <category>*StompTest-VW-Core-factory</category><body package="StompTest-VW-Core" selector="testFixturesClass">testFixturesClass	^ StompVwFixtures</body></methods><methods><class-id>StompVwPortableUtil class</class-id> <category>class initialization</category><body package="Stomp-VW-Core" selector="initialize">initialize	"StompSqPortableUtil initialize"	| klsName |	super initialize.	klsName := self name.	Smalltalk at: klsName ifPresent: [:p | StompPortableUtil dialectSpecificClass: p].</body></methods><methods><class-id>StompWarning</class-id> <category>accessing</category><body package="Stomp-Core" selector="className">className	className ifNil: [^ className].	^className asSymbol</body><body package="Stomp-Core" selector="className:">className: aValue	className := aValue</body><body package="Stomp-Core" selector="context">context	^context</body><body package="Stomp-Core" selector="context:">context: aValue	context := aValue</body><body package="Stomp-Core" selector="element">element	^ element</body><body package="Stomp-Core" selector="element:">element: aValue 	element := aValue</body></methods><methods><class-id>StompWarning</class-id> <category>signaling</category><body package="Stomp-Core" selector="signal:context:">signal: aClassName context: dictionary 	self class suppressSignaling ifTrue: [^self].	self className: aClassName.	self context: dictionary.	^MpPortableUtil default signalException: self</body></methods><methods><class-id>StompWarning</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="defaultAction">defaultAction	self class suppressTranscriptLogging ifFalse: [Transcript cr; show: '#warning# ' , self description].	self resume</body></methods><methods><class-id>StompWarning class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:">signal: className	^self signal: className context: nil </body><body package="Stomp-Core" selector="signal:context:">signal: className context: dictionary 	^ self new signal: className context: dictionary </body></methods><methods><class-id>StompWarning class</class-id> <category>accessing</category><body package="Stomp-Core" selector="suppressSignaling">suppressSignaling	^suppressSignaling ifNil: [suppressSignaling := false].</body><body package="Stomp-Core" selector="suppressSignaling:">suppressSignaling: anObject	suppressSignaling := anObject</body><body package="Stomp-Core" selector="suppressTranscriptLogging">suppressTranscriptLogging	^suppressTranscriptLogging ifNil: [suppressTranscriptLogging := false]</body><body package="Stomp-Core" selector="suppressTranscriptLogging:">suppressTranscriptLogging: anObject	suppressTranscriptLogging := anObject</body></methods><methods><class-id>StompWarning class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	"StompWarning initialize"	suppressSignaling := nil.	suppressTranscriptLogging := nil</body></methods><methods><class-id>StompSettings</class-id> <category>accessing</category><body package="Stomp-Core" selector="supportsMultibyteIdentifiers">supportsMultibyteIdentifiers	^self at: #supportsMultibyteIdentifiers ifAbsentPut: [false]</body><body package="Stomp-Core" selector="supportsMultibyteIdentifiers:">supportsMultibyteIdentifiers: aBoolean	^self at: #supportsMultibyteIdentifiers put: aBoolean</body><body package="Stomp-Core" selector="suppressNilWrite">suppressNilWrite	^ self writeVariableDefinitionsAsReference not</body><body package="Stomp-Core" selector="suppressNilWrite:">suppressNilWrite: aBoolean		^self writeVariableDefinitionsAsReference: (aBoolean==true) not</body><body package="Stomp-Core" selector="useEnvironment">useEnvironment	^self at: #useEnvironment ifAbsentPut: [StompPortableUtil default useEnvironmentByDefault]</body><body package="Stomp-Core" selector="useEnvironment:">useEnvironment: aBoolean	^self at: #useEnvironment put: aBoolean</body><body package="Stomp-Core" selector="withHeader">withHeader	^self at: #withHeader ifAbsentPut: [false]</body><body package="Stomp-Core" selector="withHeader:">withHeader: aBoolean	^self at: #withHeader put: aBoolean</body><body package="Stomp-Core" selector="writeVariableDefinitionsAsReference">writeVariableDefinitionsAsReference	^self at: #writeVariableDefinitionsAsReference ifAbsentPut: [true]</body><body package="Stomp-Core" selector="writeVariableDefinitionsAsReference:">writeVariableDefinitionsAsReference: aBoolean	^self at: #writeVariableDefinitionsAsReference put: aBoolean</body></methods><methods><class-id>StompVwTestCase</class-id> <category>tests</category><body package="StompTest-VW-Core" selector="testReadWriteDwordArray">testReadWriteDwordArray	| arr bytes |	arr := DwordArray new: 2.	arr at: 1 put: 4294967294.	arr at: 2 put: 1.	bytes := arr toStomp.	self should: [bytes = #[147 161 2 251 168 255 255 255 254 0 0 0 1]].	self should: [(Object fromStomp: bytes) = arr]</body><body package="StompTest-VW-Core" selector="testReadWriteWordArray">testReadWriteWordArray	| arr bytes |	arr := WordArray new: 2.	arr at: 1 put: 65534.	arr at: 2 put: 1.	bytes := arr toStomp.	self should: [bytes = #[147 161 2 250 164 255 254 0 1]].	self should: [(Object fromStomp: bytes) = arr]</body></methods><methods><class-id>StompClassNotFound</class-id> <category>factory</category><body package="Stomp-Core" selector="berstReadValue">berstReadValue 	^ nil</body><body package="Stomp-Core" selector="stompReadValue">stompReadValue 	^ nil</body><body package="Stomp-Core" selector="unresolvedClass">unresolvedClass	"By default my class act as an unresolved class, which instantiate nil"	^self class</body></methods><methods><class-id>StompClassNotFound</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="defaultAction">defaultAction	Transcript cr; show: '#warning# ' , self description.	^ self unresolvedClass</body><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompClassNotFound</class-id> <category>accessing</category><body package="Stomp-Core" selector="environmentName">environmentName	"Answer the value of environmentName"	environmentName ifNil: [^ environmentName].	^ environmentName</body><body package="Stomp-Core" selector="environmentName:">environmentName: anObject	"Set the value of environmentName"	environmentName := anObject</body></methods><methods><class-id>StompClassNotFound class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="signal:environment:context:">signal: className environment: envName context: dictionary 	| inst |	inst := self new.	inst environmentName: envName.	^ inst signal: className context: dictionary </body></methods><methods><class-id>StompMockCustomWriteObject</class-id> <category>accessing</category><body package="StompTest-Core" selector="email">email	"Answer the value of email"	^ email</body><body package="StompTest-Core" selector="email:">email: anObject	"Set the value of email"	email := anObject</body><body package="StompTest-Core" selector="name">name	^name</body><body package="StompTest-Core" selector="name:">name: anObject	"Set the value of name"	name := anObject</body></methods><methods><class-id>StompMockCustomWriteObject</class-id> <category>initialize-release</category><body package="StompTest-Core" selector="initialize">initialize	name := 'Test Name'.	email := 'test-name@example.com'</body></methods><methods><class-id>StompMockCustomWriteObject</class-id> <category>stomp-objectstream-writing</category><body package="StompTest-Core" selector="stompWriteValue">stompWriteValue	"Write myself as an array"	^StompMockMementoArray with: self name with: self email</body></methods><methods><class-id>StompReaderTestCase</class-id> <category>tests</category><body package="StompTest-Core" selector="testReadBag">testReadBag	"self debug: #testReadBag"		| bytes inst |	bytes := self bagAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Bag].	self		should: [inst size = 4].	self		should: [inst includes: 10].	self		should: [inst includes: 20].	self		should: [inst includes: 30].	self		should: [(inst occurrencesOf: 30) = 2]</body><body package="StompTest-Core" selector="testReadBasicArray">testReadBasicArray	"self debug: #testReadBasicArray"	| bytes obj |	bytes := self basicArrayAnswerBytes.	obj := (StompReader onBytes: bytes) next.		self should: [obj class = Array].	self should: [obj = #(1 2 3 #('Hello' 2 3))]</body><body package="StompTest-Core" selector="testReadBasicBitsClass">testReadBasicBitsClass	"self debug: #testReadBasicBitsClass"	| bytes obj expected |	bytes := self basicBitsClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockByteArray new: 3.	expected at: 1 put: 0.	expected at: 2 put: 127.	expected at: 3 put: 255.	self should: [obj = expected].			</body><body package="StompTest-Core" selector="testReadBasicFixedClass">testReadBasicFixedClass	"self debug: #testReadBasicFixedClass"	| bytes obj expected |	bytes := self basicFixedClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #two.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [obj equals: expected].</body><body package="StompTest-Core" selector="testReadBasicMixedClass">testReadBasicMixedClass	"self debug: #testReadBasicMixedClass"	| bytes obj expected |	bytes := self basicMixedClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockMixedClass new: 3.	expected at: 1 put: 1.	expected at: 2 put: 'two'.	expected at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar1: #(true false).	expected instVar2: #(nil #()).		self should: [obj equals: expected]</body><body package="StompTest-Core" selector="testReadBasicVariableClass">testReadBasicVariableClass	"self debug: #testReadBasicVariableClass"	| bytes obj expected |	bytes := self basicVariableClassAnswerBytes.	obj := (StompReader onBytes: bytes) next.		expected := StompMockVariableClass new: 3.	expected at: 1 put: 1.	expected at: 2 put: 'two'.	expected at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		self should: [obj = expected]</body><body package="StompTest-Core" selector="testReadBoolean">testReadBoolean	"self debug: #testReadBoolean"		self should: [(Object fromStomp: (#[195])) = true].	self should: [(Object fromStomp: (#[194])) = false].</body><body package="StompTest-Core" selector="testReadByteArray">testReadByteArray	"self debug: #testReadByteArray"		| byteArray |	byteArray := (ByteArray with: 10 with: 20 with: 30).		self should: [(Object fromStomp: (#[163 10 20 30])) = byteArray].	</body><body package="StompTest-Core" selector="testReadCharacter">testReadCharacter	"self debug: #testReadCharacter"		| char1 char2 |	char1 := $A.		self should: [(Object fromStomp:(#[147 161 2 227 65])) = char1].	char2 := (StompPortableUtil default characterFromUnicode: 12354). "Japanese Hiragana 'A' "		self should: [(Object fromStomp:(#[147 161 2 227 205 48 66])) = char2].		</body><body package="StompTest-Core" selector="testReadCircularRefrences1">testReadCircularRefrences1	"self debug: #testReadCircularRefrences1"	| bytes reader obj inst1 inst2 expected |	bytes := self circularRefrencesAnswerBytes.	reader := StompReader onBytes: bytes.	obj := reader next.		inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: inst1.		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: inst1.	inst2 instVar2: inst2.		expected := Array with: inst1 with: inst2 with: inst1 with: inst2.		self should: [obj class = expected class].	self should: [obj size = expected size]. 		self should: [(obj at: 1) class = StompMockVariableClass].	self should: [(obj at: 1) class = (expected at: 1) class].	self should: [((obj at: 1) at: 1) = 1].	self should: [((obj at: 1) at: 1) = ((expected at: 1) at: 1)].	self should: [((obj at: 1) at: 2) = 'two'].	self should: [((obj at: 1) at: 2) = ((expected at: 1) at: 2)].	self should: [((obj at: 1) at: 3) class = StompMockVariableClass].	self should: [((obj at: 1) at: 3) class = ((expected at: 1) at: 3) class].	self should: [(obj at: 1) identityHash = ((obj at: 1) at: 3) identityHash].		self should: [(obj at: 2) class = StompMockMixedClass].	self should: [(obj at: 2) class = (expected at: 2) class].	self should: [((obj at: 2) at: 1) = 1].	self should: [((obj at: 2) at: 1) = ((expected at: 2) at: 1)].	self should: [((obj at: 2) at: 2) = 'two'].	self should: [((obj at: 2) at: 2) = ((expected at: 2) at: 2)].	self should: [((obj at: 2) at: 3) = (StompPortableUtil default testFixturesClass double3dot3)].	self should: [((obj at: 2) at: 3) = ((expected at: 2) at: 3)].	self should: [((obj at: 2) instVar1) class = StompMockVariableClass].	self should: [((obj at: 2) instVar1) class = ((expected at: 2) instVar1) class].	self should: [(obj at: 2) instVar1 identityHash = (obj at: 1) identityHash].	self should: [((obj at: 2) instVar2) class = StompMockMixedClass].	self should: [((obj at: 2) instVar2) class = ((expected at: 2) instVar2) class].	self should: [(obj at: 2) instVar2 identityHash = (obj at: 2) identityHash].		self should: [(obj at: 3) class = StompMockVariableClass].	self should: [(obj at: 3) class = (expected at: 3) class].	self should: [((obj at: 3) at: 1) = 1].	self should: [((obj at: 3) at: 1) = ((expected at: 3) at: 1)].	self should: [((obj at: 3) at: 2) = 'two'].	self should: [((obj at: 3) at: 2) = ((expected at: 3) at: 2)].	self should: [((obj at: 3) at: 3) class = StompMockVariableClass].	self should: [((obj at: 3) at: 3) class = ((expected at: 3) at: 3) class].	self should: [(obj at: 3) identityHash = ((obj at: 3) at: 3) identityHash].		self should: [(obj at: 4) class = StompMockMixedClass].	self should: [(obj at: 4) class = (expected at: 4) class].	self should: [((obj at: 4) at: 1) = 1].	self should: [((obj at: 4) at: 1) = ((expected at: 4) at: 1)].	self should: [((obj at: 4) at: 2) = 'two'].	self should: [((obj at: 4) at: 2) = ((expected at: 4) at: 2)].	self should: [((obj at: 4) at: 3) = (StompPortableUtil default testFixturesClass double3dot3)].	self should: [((obj at: 4) at: 3) = ((expected at: 4) at: 3)].	self should: [((obj at: 4) instVar1) class = StompMockVariableClass].	self should: [((obj at: 4) instVar1) class = ((expected at: 4) instVar1) class].	self should: [(obj at: 4) instVar1 identityHash = (obj at: 1) identityHash].	self should: [((obj at: 4) instVar2) class = StompMockMixedClass].	self should: [((obj at: 4) instVar2) class = ((expected at: 4) instVar2) class].	self should: [(obj at: 4) instVar2 identityHash = (obj at: 2) identityHash].</body><body package="StompTest-Core" selector="testReadClass">testReadClass	"self debug: #testReadClass"	| cls |	cls := StompMockObjectWithCache.	cls att1: 11.	cls att2: 22.	self should: [(Object fromStomp: (self classAnswerBytes)) = cls]		</body><body package="StompTest-Core" selector="testReadClassNameAndIds">testReadClassNameAndIds	"self debug: #testReadClassNameAndIds"		| bytes obj data1 data2 data3 data4 expected |	bytes := self classNameAndIdsAnswerBytes.	obj := (StompReader onBytes: bytes) next.		data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		expected := Array with: data1 with: data2 with: data3 with: data4.		self should: [(obj at: 1) equals: (expected at: 1)].	self should: [(obj at: 2) equals: (expected at: 2)].	self should: [(obj at: 3) equals: (expected at: 3)].	self should: [(obj at: 4) equals: (expected at: 4)]				</body><body package="StompTest-Core" selector="testReadClassNameAndIdsSuppressNilWrites">testReadClassNameAndIdsSuppressNilWrites	"self debug: #testReadClassNameAndIdsSuppressNilWrites"		| bytes obj data1 data2 data3 data4 expected |	bytes := self classNameAndIdsSuppressNilWritesAnswerBytes.	obj := (StompReader onBytes: bytes) next.		data1 := StompMockFixedClass new.	data1 instVar1: 1.	data1 instVar2: #one.		data2 := StompMockFixedClass new.	data2 instVar1: 2.	data2 instVar2: #two.		data3 := StompMockMixedClass new.	data3 instVar1: 3.	data3 instVar2: #three.		data4 := StompMockMixedClass new.	data4 instVar1: 4.	data4 instVar2: #four.		expected := Array with: data1 with: data2 with: data3 with: data4.		self should: [(obj at: 1) equals: (expected at: 1)].	self should: [(obj at: 2) equals: (expected at: 2)].	self should: [(obj at: 3) equals: (expected at: 3)].	self should: [(obj at: 4) equals: (expected at: 4)]				</body><body package="StompTest-Core" selector="testReadColor">testReadColor	"self debug: #testReadColor"	| color1 color2 |	color1 := StompPortableUtil default testFixturesClass blueColor.	self should: [(Object fromStomp:(self colorAnswerBytes1)) = color1].		color2 := StompPortableUtil default testFixturesClass yellowColor.	self should: [(Object fromStomp:(self colorAnswerBytes2)) = color2]		</body><body package="StompTest-Core" selector="testReadCompositeDictionary">testReadCompositeDictionary	"self debug: #testReadCompositeDictionary"	| childDic dic |	childDic := Dictionary new.	childDic at: #child1 put: 'abcde'.	dic := Dictionary new.	dic at: #parent1 put: 'sample string.'.	dic at: #parent2 put: 100.	dic at: #parent3 put: #(10 20 30 ).	dic at: #parent4 put: childDic.	self should: [(Object fromStomp: (self compositeDictionaryAnswerBytes)) = dic]</body><body package="StompTest-Core" selector="testReadDate">testReadDate	"self debug: #testReadDate"		| bytes inst |	bytes := self dateAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Date].	self should: [inst = (Date fromDays: 37023)].	</body><body package="StompTest-Core" selector="testReadDictionary">testReadDictionary	"self debug: #testReadDictionary"	| dic |	dic := Dictionary new.	dic at: #key1 put: 'value1'.	dic at: #key2 put: 'value2'.	dic at: #key3 put: 'value3'.		self should: [(Object fromStomp: (self dictionaryAnswerBytes)) = dic]</body><body package="StompTest-Core" selector="testReadDuration">testReadDuration	"self debug: #testReadDuration"		| duration inst |	duration := self durationAnswerBytes.	inst := Object fromStomp: duration.		self should: [inst class = Duration].	self should: [inst = 123 seconds].	</body><body package="StompTest-Core" selector="testReadFixedClassWithNilValues">testReadFixedClassWithNilValues	"self debug: #testReadFixedClassWithNilValues"	| data |	data := StompMockFixedClass new.	data instVar1: 1.	data instVar2: nil.	data instVar3: (StompPortableUtil default testFixturesClass double3dot3).	data instVar4: nil.	data instVar5: 'FIVE'.	self		should: [data				equals: (Object						fromStomp: self fixedClassWithNilValuesAnswerBytes						setting: [:ctx | ctx settings suppressNilWrite: true])]</body><body package="StompTest-Core" selector="testReadFraction">testReadFraction	"self debug: #testReadFraction"	| fra |	fra := 3 / 4.		self should: [(Object fromStomp: (self fractionAnswerBytes)) = fra]</body><body package="StompTest-Core" selector="testReadInterval">testReadInterval	"self debug: #testReadInterval"	| interval |	interval := 1 to: 10 by: 3.		self should: [(Object fromStomp: (self intervalAnswerBytes)) = interval]	</body><body package="StompTest-Core" selector="testReadMixedClassNoVariableData">testReadMixedClassNoVariableData	"self debug: #testReadMixedClassNoVariableData"	| data |	data := StompMockMixedClass new.	data instVar1: #(true false).	data instVar2: #(nil #()).	self should: [data equals: (Object fromStomp:(self mixedClassNoVariableDataAnswerBytes))]	</body><body package="StompTest-Core" selector="testReadNumber">testReadNumber	"self debug: #testReadNumber"	self should: [(Object fromStomp:(#[1])) = 1].	self should: [(Object fromStomp:(self floatingPointAnswerBytes1)) = 1.2].	self should: [(Object fromStomp:(self floatingPointAnswerBytes2))  = StompPortableUtil default testFixturesClass double1234567890dot123456789]</body><body package="StompTest-Core" selector="testReadOrdredCollection">testReadOrdredCollection	"self debug: #testReadOrdredCollection"	| ord |	ord := OrderedCollection new.	ord add: 10.	ord add: 20.	ord add: 30.		self should: [(Object fromStomp:(self ordredCollectionAnswerBytes)) = ord]	</body><body package="StompTest-Core" selector="testReadRectangle">testReadRectangle	"self debug: #testReadRectangle"	| rect |	rect := (1@1 corner: 3@4).		self should: [(Object fromStomp:(self rectangleAnswerBytes)) = rect]		</body><body package="StompTest-Core" selector="testReadRecursiveArray">testReadRecursiveArray	"self debug: #testReadRecursiveArray"	| arr readArray |	arr := Array new: 3.	arr at: 1 put: 10.	arr at: 2 put: 20.	arr at: 3 put: arr.		readArray := (Object fromStomp:(self recursiveArrayAnswerBytes)).		self should: [readArray size = arr size].	self should: [(readArray at: 1) = (arr at: 1)].	self should: [(readArray at: 2) = (arr at: 2)].	self should: [(readArray at: 3) identityHash= readArray identityHash].		</body><body package="StompTest-Core" selector="testReadRunArray">testReadRunArray	"self debug: #testReadRunArray"	| arr |	arr := RunArray runs: #(1 2 1) values: #(1 2 3).	self should: [(Object fromStomp:(self runArrayAnswerBytes)) = arr]	</body><body package="StompTest-Core" selector="testReadSet">testReadSet	"self debug: #testReadSet"	| set |	set := Set new.	set add: 10.	set add: 20.	set add: 30.	set add: 30.		self should: [(Object fromStomp:(self setAnswerBytes)) = set]	</body><body package="StompTest-Core" selector="testReadSharedRefrences1">testReadSharedRefrences1	"self debug: #testReadSharedRefrences1"	| bytes reader obj inst1 inst2 expected  |	bytes := self sharedReferenceAnswerBytes.	reader := StompReader onBytes: bytes.	obj := reader next.		inst1 := StompMockVariableClass new: 3.	inst1 at: 1 put: 1.	inst1 at: 2 put: 'two'.	inst1 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).		inst2 := StompMockMixedClass new: 3.	inst2 at: 1 put: 1.	inst2 at: 2 put: 'two'.	inst2 at: 3 put: (StompPortableUtil default testFixturesClass double3dot3).	inst2 instVar1: #(true false).	inst2 instVar2: #(nil #()).		expected := Array with: inst1 with: inst2 with: inst1 with: inst2.		self should: [obj = expected].</body><body package="StompTest-Core" selector="testReadString">testReadString	"self debug: #testReadString"	| str1 |	str1 := 'Hi, I''m String-object'.	self should: [(Object fromStomp:(self stringAnswerBytes)) = str1].		</body><body package="StompTest-Core" selector="testReadTime">testReadTime	"self debug: #testReadTime"		| bytes inst |	bytes := self timeAnswerBytes.	inst := Object fromStomp: bytes.		self should: [inst class = Time].	self should: [inst = (Time fromSeconds: 84072)].	</body><body package="StompTest-Core" selector="testReadTimestamp">testReadTimestamp	"self debug: #testReadTimestamp"		| timestamp |	timestamp := StompPortableUtil default testFixturesClass timestamp1.	self should: [(Object fromStomp: (self timestampAnswerBytes)) = timestamp]	</body><body package="StompTest-Core" selector="testReadUndefinedObject">testReadUndefinedObject	"self debug: #testReadUndefinedObject"	self should: [(Object fromStomp:(#[192])) = nil].		</body></methods><methods><class-id>StompMockFixedClass</class-id> <category>accessing</category><body package="StompTest-Core" selector="instVar1">instVar1	"Answer the value of instVar1"	^ instVar1</body><body package="StompTest-Core" selector="instVar1:">instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject</body><body package="StompTest-Core" selector="instVar2">instVar2	"Answer the value of instVar2"	^ instVar2</body><body package="StompTest-Core" selector="instVar2:">instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject</body><body package="StompTest-Core" selector="instVar3">instVar3	"Answer the value of instVar3"	^ instVar3</body><body package="StompTest-Core" selector="instVar3:">instVar3: anObject	"Set the value of instVar3"	instVar3 := anObject</body><body package="StompTest-Core" selector="instVar4">instVar4	"Answer the value of instVar4"	^ instVar4</body><body package="StompTest-Core" selector="instVar4:">instVar4: anObject	"Set the value of instVar4"	instVar4 := anObject</body><body package="StompTest-Core" selector="instVar5">instVar5	"Answer the value of instVar5"	^ instVar5</body><body package="StompTest-Core" selector="instVar5:">instVar5: anObject	"Set the value of instVar5"	instVar5 := anObject</body></methods><methods><class-id>StompMockFixedClass</class-id> <category>comparing</category><body package="StompTest-Core" selector="equals:">equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	instVar3 = other instVar3 ifFalse: [^false].	instVar4 = other instVar4 ifFalse: [^false].	instVar5 = other instVar5 ifFalse: [^false].	^true</body></methods><methods><class-id>StompMockObjectInitializingOnRead</class-id> <category>initialize-release</category><body package="StompTest-Core" selector="stompInitialize">stompInitialize	instVar1 := 'stomp initialized 1'.	instVar2 := 'stomp initialized 2'</body></methods><methods><class-id>StompMockFixedNewFailedClass</class-id> <category>accessing</category><body package="StompTest-Core" selector="att1">att1	^att1</body><body package="StompTest-Core" selector="att1:">att1: aValue	att1 := aValue</body><body package="StompTest-Core" selector="att2">att2	^att2</body><body package="StompTest-Core" selector="att2:">att2: aValue	att2 := aValue</body><body package="StompTest-Core" selector="att3Block">att3Block	^att3Block</body><body package="StompTest-Core" selector="att3Block:">att3Block: aValue	att3Block := aValue</body></methods><methods><class-id>StompMockFixedNewFailedClass</class-id> <category>initializing-stomp</category><body package="StompTest-Core" selector="stompInitialize">stompInitialize	att3Block := [:a :b | a &lt; b].</body></methods><methods><class-id>StompMockFixedNewFailedClass class</class-id> <category>for tests</category><body package="StompTest-Core" selector="prototype1">prototype1	"self prototype1"	| inst |	inst := self basicNew.	inst att1: 1.	inst att2: 'TWO'.	inst att3Block: [:this | 'is block'].	^inst</body></methods><methods><class-id>StompMockFixedNewFailedClass class</class-id> <category>instance creation</category><body package="StompTest-Core" selector="new">new	^Error new signal: '#new should not be used!'</body></methods><methods><class-id>StompMockFixedAlternativeClass class</class-id> <category>instance creation</category><body package="StompTest-Core" selector="new">new	"new is OK for me"	^self basicNew</body></methods><methods><class-id>StompMockShapeChangedObject</class-id> <category>reading-stomp</category><body package="StompTest-Core" selector="stompInitialize">stompInitialize	addedAtt1 := 2</body><body package="StompTest-Core" selector="stompInstVarAt:named:put:">stompInstVarAt: instVarIndex named: varName put: value 	varName = 'oldNamedVar1' ifTrue: [^self renamedAtt1: value].	super stompInstVarAt: instVarIndex named: varName put: value </body></methods><methods><class-id>StompMockShapeChangedObject</class-id> <category>accessing</category><body package="StompTest-Core" selector="addedAtt1">addedAtt1	"Answer the value of addedAtt1"	^ addedAtt1</body><body package="StompTest-Core" selector="addedAtt1:">addedAtt1: anObject	"Set the value of addedAtt1"	addedAtt1 := anObject</body><body package="StompTest-Core" selector="originalAtt1">originalAtt1	"Answer the value of originalAtt1"	^ originalAtt1</body><body package="StompTest-Core" selector="originalAtt1:">originalAtt1: anObject	"Set the value of originalAtt1"	originalAtt1 := anObject</body><body package="StompTest-Core" selector="renamedAtt1">renamedAtt1	"Answer the value of renamedAtt1"	^ renamedAtt1</body><body package="StompTest-Core" selector="renamedAtt1:">renamedAtt1: anObject	"Set the value of renamedAtt1"	renamedAtt1 := anObject</body></methods><methods><class-id>StompFieldsInfo</class-id> <category>accessing</category><body package="Stomp-Core" selector="indexFieldSize">indexFieldSize	"Answer the value of indexFieldSize"	^ indexFieldSize</body><body package="Stomp-Core" selector="indexFieldSize:">indexFieldSize: anObject	"Set the value of indexFieldSize"	indexFieldSize := anObject</body><body package="Stomp-Core" selector="type">type	"Answer the value of type"	^ type</body><body package="Stomp-Core" selector="type:">type: anObject	"Set the value of type"	type := anObject</body></methods><methods><class-id>StompFieldsInfo</class-id> <category>testing</category><body package="Stomp-Core" selector="isMixedFields">isMixedFields	^ self type == #mixedFields</body><body package="Stomp-Core" selector="isPureIndexFields">isPureIndexFields	^ self type == #pureIndexFields</body></methods><methods><class-id>StompFieldsInfo class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="mixedFields">mixedFields	^ self type: #mixedFields</body><body package="Stomp-Core" selector="pureIndexFields">pureIndexFields	^ self type: #pureIndexFields</body><body package="Stomp-Core" selector="pureIndexFieldsSized:">pureIndexFieldsSized: numOfFields	^ self pureIndexFields indexFieldSize: numOfFields</body><body package="Stomp-Core" selector="type:">type: typeSymbol	^ self new type: typeSymbol; yourself</body></methods><methods><class-id>StompPortableFixtures class</class-id> <category>fixtures</category><body package="StompTest-Core" selector="blueColor">blueColor	self subclassResponsibility </body><body package="StompTest-Core" selector="double1234567890dot123456789">double1234567890dot123456789	"^ 1234567890.123456789d"	self subclassResponsibility</body><body package="StompTest-Core" selector="double3dot3">double3dot3	"^ 3.3d"	self subclassResponsibility</body><body package="StompTest-Core" selector="float1dot2bytes">float1dot2bytes	^ #[202 63 153 153 154]</body><body package="StompTest-Core" selector="timestamp1">timestamp1	self subclassResponsibility</body><body package="StompTest-Core" selector="yellowColor">yellowColor	self subclassResponsibility </body></methods><methods><class-id>StompMockPerson</class-id> <category>accessing</category><body package="StompTest-Core" selector="name">name	^name</body><body package="StompTest-Core" selector="name:">name: aString	name := aString</body><body package="StompTest-Core" selector="partners">partners	partners isNil ifTrue: [partners := Array new].	^ partners</body><body package="StompTest-Core" selector="partners:">partners: anObject	partners := anObject</body><body package="StompTest-Core" selector="requests">requests	requests isNil ifTrue: [requests := Array new].	^ requests</body><body package="StompTest-Core" selector="requests:">requests: anObject	requests := anObject</body></methods><methods><class-id>StompMockPerson class</class-id> <category>examples</category><body package="StompTest-Core" selector="example1">example1	"self example1"	| req1 req2 person1 person2 |	req1 := StompMockRequest new.	req1 id: 1.	req2 := StompMockRequest new.		req2 id: 2.	person1 := StompMockPerson new name: 'A'.	person1 requests: (Array with: req1 with: req2).	person2 := StompMockPerson new name: 'B'.	person2 partners: (Array with: person1).	req1 owner: person1.	req2 owner: person2.	^person1	</body></methods><methods><class-id>StompShapeChanger</class-id> <category>actions</category><body package="Stomp-Core" selector="loadAdditions">loadAdditions	"override"</body><body package="Stomp-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	"override"	 self targetInstance stompInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompShapeChanger</class-id> <category>accessing</category><body package="Stomp-Core" selector="targetInstance">targetInstance	"Answer the value of targetInstance"	^ targetInstance</body><body package="Stomp-Core" selector="targetInstance:">targetInstance: anObject	"Set the value of targetInstance"	targetInstance := anObject</body></methods><methods><class-id>StompShapeChanger</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="on:">on: anInstance 	self targetInstance: anInstance</body></methods><methods><class-id>StompShapeChanger class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="on:">on: anInstance 	^ self new on: anInstance;		 yourself</body></methods><methods><class-id>StompConstants class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initTupleTags">initTupleTags	"self initTupleTags"	tupleTags := Set new.	tupleTags add: self value.	tupleTags add: self reference.	tupleTags add: self byteString.	tupleTags add: self byteSymbol.	tupleTags add: self wideString.	tupleTags add: self wideSymbol.</body><body package="Stomp-Core" selector="initialize">initialize	"self initialize"	self initTupleTags	</body></methods><methods><class-id>StompConstants class</class-id> <category>tuple tags</category><body package="Stomp-Core" selector="byteString">byteString	^16r04</body><body package="Stomp-Core" selector="byteSymbol">byteSymbol	^16r05</body><body package="Stomp-Core" selector="reference">reference	^16r03</body><body package="Stomp-Core" selector="value">value	^16r02</body><body package="Stomp-Core" selector="wideString">wideString	^16r06</body><body package="Stomp-Core" selector="wideSymbol">wideSymbol	^16r07</body></methods><methods><class-id>StompConstants class</class-id> <category>attribute-tags</category><body package="Stomp-Core" selector="classCode">classCode	^16r15</body><body package="Stomp-Core" selector="classId">classId	^16r12</body><body package="Stomp-Core" selector="environmentId">environmentId	^16r14</body><body package="Stomp-Core" selector="environmentName">environmentName	^16r13</body><body package="Stomp-Core" selector="klassName">klassName	^16r11</body></methods><methods><class-id>StompConstants class</class-id> <category>accessing</category><body package="Stomp-Core" selector="header">header	^'SP' asByteArray</body><body package="Stomp-Core" selector="tupleTags">tupleTags	^tupleTags</body></methods><methods><class-id>StompConstants class</class-id> <category>actions</category><body package="Stomp-Core" selector="isTupleTag:">isTupleTag: tag	^tag isInteger and: [self tupleTags includes: tag]</body></methods><methods><class-id>StompInvalidDeserialization</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompReadContext</class-id> <category>renaming</category><body package="Stomp-Core" selector="registerClassOldName:for:">registerClassOldName: oldClassNameSymbol for: existingClass	^ self registerClassOldName: oldClassNameSymbol in: nil for: existingClass</body><body package="Stomp-Core" selector="registerClassOldName:in:for:">registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier for: existingClass	| key |	key := oldEnvironmentQualifier isNil				ifTrue: [oldClassNameSymbol]				ifFalse: [Array with: oldEnvironmentQualifier with: oldClassNameSymbol].	^ self classAliasesDictionary at: key put: existingClass</body><body package="Stomp-Core" selector="registerClassOldName:in:shapeChanger:for:">registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier shapeChanger: shapeChangerClass for: existingClass	self registerClassOldName: oldClassNameSymbol in: oldEnvironmentQualifier for: existingClass.	self registerShapeChanger: shapeChangerClass for: existingClass.</body><body package="Stomp-Core" selector="registerClassOldName:shapeChanger:for:">registerClassOldName: oldClassNameSymbol shapeChanger: shapeChangerClass for: existingClass	self registerClassOldName: oldClassNameSymbol for: existingClass.	self registerShapeChanger: shapeChangerClass for: existingClass.</body></methods><methods><class-id>StompReadContext</class-id> <category>accessing</category><body package="Stomp-Core" selector="classAliasesDictionary">classAliasesDictionary	^ classAliasesDictionary ifNil: [classAliasesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="classAliasesDictionary:">classAliasesDictionary: anObject	"Set the value of classAliasesDictionary"	classAliasesDictionary := anObject</body><body package="Stomp-Core" selector="classIdsDictionary">classIdsDictionary		^ classIdsDictionary ifNil: [classIdsDictionary := Dictionary new]</body><body package="Stomp-Core" selector="classIdsDictionary:">classIdsDictionary: anObject	"Set the value of classIdsDictionary"	classIdsDictionary := anObject</body><body package="Stomp-Core" selector="environmentNamesDictionary">environmentNamesDictionary	^environmentNamesDictionary ifNil: [environmentNamesDictionary := Dictionary new]</body><body package="Stomp-Core" selector="environmentNamesDictionary:">environmentNamesDictionary: anObject	environmentNamesDictionary := anObject</body><body package="Stomp-Core" selector="fieldsInfo">fieldsInfo	"Answer the value of mixedFieldHint"	^ fieldsInfo</body><body package="Stomp-Core" selector="fieldsInfo:">fieldsInfo: anObject	"Set the value of mixedFieldHint"	fieldsInfo := anObject</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary">instVarNamesWithIndicesDictionary	^ instVarNamesWithIndicesDictionary ifNil: [instVarNamesWithIndicesDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="instVarNamesWithIndicesDictionary:">instVarNamesWithIndicesDictionary: anObject	"Set the value of instVarNamesWithIndicesDictionary"	instVarNamesWithIndicesDictionary := anObject</body><body package="Stomp-Core" selector="shapeChangersDictionary">shapeChangersDictionary	^ shapeChangersDictionary ifNil: [shapeChangersDictionary := IdentityDictionary new]</body><body package="Stomp-Core" selector="shapeChangersDictionary:">shapeChangersDictionary: anObject	"Set the value of shapeChangersDictionary"	shapeChangersDictionary := anObject</body></methods><methods><class-id>StompReadContext</class-id> <category>actions</category><body package="Stomp-Core" selector="classAt:">classAt: classId	^self classIdsDictionary at: classId ifAbsent: []</body><body package="Stomp-Core" selector="classNamed:in:">classNamed: localClassName in: environmentQualifier 	| qualifier isClassClass localClassNameSize className foundClass |	qualifier := self settings useEnvironment ifTrue: [environmentQualifier].		isClassClass := false.	localClassNameSize := localClassName size.	className := ((localClassName at: (localClassNameSize)) = $$)				ifTrue: [isClassClass := true.					localClassName copyFrom: 1 to: (localClassNameSize-1)]				ifFalse: [localClassName].					foundClass := self mappedClassAt: className asSymbol in: qualifier.		isClassClass ifTrue: [foundClass := foundClass class].		^ foundClass</body><body package="Stomp-Core" selector="environmentNameAt:">environmentNameAt: envId	^ self environmentNamesDictionary at: envId ifAbsent: [].</body><body package="Stomp-Core" selector="instVarNamesWithIndicesAt:">instVarNamesWithIndicesAt: classId	| klass |	klass := self classAt: classId.	^ self instVarNamesWithIndicesDictionary at: klass ifAbsent: [#()]</body><body package="Stomp-Core" selector="rememberClass:">rememberClass: aClass	^ self classIdsDictionary at: self classIdsDictionary size put: aClass</body><body package="Stomp-Core" selector="rememberEnvironmentName:">rememberEnvironmentName: aString	^ self environmentNamesDictionary at: (self environmentNamesDictionary size) put: aString</body><body package="Stomp-Core" selector="rememberInstVarNames:indices:of:">rememberInstVarNames: instVarNames indices: instVarIndices of: aClass	| ord |	ord := OrderedCollection new: instVarNames size.	instVarNames with: instVarIndices do: [:name :idx | ord add: (Array with: name with: idx)]. 	self instVarNamesWithIndicesDictionary at: aClass put: ord.	^ord</body></methods><methods><class-id>StompReadContext</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="clearFieldsInfo">clearFieldsInfo	fieldsInfo := nil</body></methods><methods><class-id>StompReadContext</class-id> <category>private</category><body package="Stomp-Core" selector="mappedClassAt:in:">mappedClassAt: classNameSymbol in: environmentQualifier 	| classNameSymbolOrNewClass |	classNameSymbolOrNewClass := self mappedClassNameAt: classNameSymbol asSymbol in: environmentQualifier.	^ classNameSymbolOrNewClass isBehavior 		ifTrue: [classNameSymbolOrNewClass]		ifFalse: [StompPortableUtil default classNamed: classNameSymbolOrNewClass in: environmentQualifier].</body><body package="Stomp-Core" selector="mappedClassNameAt:in:">mappedClassNameAt: classNameSymbol in: environmentQualifier 	| key |	key := environmentQualifier isNil				ifTrue: [classNameSymbol]				ifFalse: [Array with: environmentQualifier with: classNameSymbol].	^ self classAliasesDictionary		at: key		ifAbsent: [classNameSymbol]</body></methods><methods><class-id>StompReadContext</class-id> <category>shape changing</category><body package="Stomp-Core" selector="registerShapeChanger:for:">registerShapeChanger: shapeChangerObject for: existingClass	^self shapeChangersDictionary at: existingClass put: shapeChangerObject</body><body package="Stomp-Core" selector="registerShapeChangerRenameBy:for:">registerShapeChangerRenameBy: loadInstVarsBlock for: existingClass	^self registerShapeChangerRenameBy: loadInstVarsBlock initializeBy: nil for: existingClass</body><body package="Stomp-Core" selector="registerShapeChangerRenameBy:initializeBy:for:">registerShapeChangerRenameBy: loadInstVarsBlock initializeBy: loadAdditionsBlock for: existingClass	| changer |	changer := StompBlockShapeChanger loadInstVarsBlock: loadInstVarsBlock loadAdditionsBlock: loadAdditionsBlock.	^self shapeChangersDictionary at: existingClass put: changer</body><body package="Stomp-Core" selector="shapeChangerFor:">shapeChangerFor: existingClass	shapeChangersDictionary ifNil: [^nil].	^self shapeChangersDictionary at: existingClass ifAbsent: []</body></methods><methods><class-id>StompReadContext</class-id> <category>defaults</category><body package="Stomp-Core" selector="objectDictionaryClass">objectDictionaryClass	^Dictionary</body></methods><methods><class-id>StompMockObjectPreparingOnWrite</class-id> <category>stomp-objectstream-writing</category><body package="StompTest-Core" selector="stompPrepareWrite">stompPrepareWrite 	self instVar1: self instVar1 printString.	self instVar2: self instVar2 * 2.</body></methods><methods><class-id>StompWriter</class-id> <category>private</category><body package="Stomp-Core" selector="bytesFromIdentifierString:">bytesFromIdentifierString: aString 	"Usually class &amp; variable names are single bytes"	^ self settings supportsMultibyteIdentifiers		ifTrue: [self portableUtil bytesFromString: aString]		ifFalse: [aString asByteArray]</body><body package="Stomp-Core" selector="classNameOf:">classNameOf: anObject	| kls |	kls := anObject class.	^ kls isMeta ifTrue: [kls soleInstance name, '$'] ifFalse: [kls name]</body><body package="Stomp-Core" selector="rememberReferenceOf:">rememberReferenceOf: originalObject	^ self context rememberReferenceOf: originalObject</body></methods><methods><class-id>StompWriter</class-id> <category>dispatching</category><body package="Stomp-Core" selector="writeObject:">writeObject: anObject	"Main dispatching method"	| writeObject |	anObject stompPrepareWrite.	(self supportsReferenceFor: anObject) ifTrue: [			self putReferenceOf: anObject ifExists: [:refId | ^self writeReference: refId].	].	writeObject := anObject stompWriteValue.		self writeValue: writeObject.	anObject stompAfterWrite	</body><body package="Stomp-Core" selector="writeStompFrom:">writeStompFrom: anObject 	(self settings withHeader and: [self writeStream position = 0])		ifTrue: [self writeVersion].	self writeObject: anObject</body></methods><methods><class-id>StompWriter</class-id> <category>factory</category><body package="Stomp-Core" selector="settingsClass">settingsClass	^StompSettings</body></methods><methods><class-id>StompWriter</class-id> <category>writing</category><body package="Stomp-Core" selector="writeByteString:">writeByteString: aString	self writeArraySize: 2.	self writeTag: StompConstants byteString.	self writeRawBytes: aString asByteArray</body><body package="Stomp-Core" selector="writeByteSymbol:">writeByteSymbol: aSymbol	self writeArraySize: 2.	self writeTag: StompConstants byteSymbol.	self writeRawBytes: aSymbol asByteArray</body><body package="Stomp-Core" selector="writeEmbeddedValue:ifNotApplied:">writeEmbeddedValue: writeObject ifNotApplied: aBlock	writeObject isSymbol ifTrue: [^self writeSymbol: writeObject].	writeObject isString ifTrue: [^self writeString: writeObject].	^ aBlock value</body><body package="Stomp-Core" selector="writeReference:">writeReference: refId	self writeArraySize: 2.	self writeTag: StompConstants reference.	self writeInteger: refId</body><body package="Stomp-Core" selector="writeStandardValue:">writeStandardValue: writeObject 	| sz writeObjectClass attributes |	sz := 2 + writeObject stompValueContentSize. 	self writeArraySize: sz.	self writeTag: StompConstants value.	writeObjectClass := writeObject class.	self portableUtil popularClassMap codeAt: writeObjectClass ifPresent: [:code | 		self writeInteger: code negated.		^ self writeContent: writeObject.	].	(self context includesClass: writeObjectClass)	ifTrue: [| classId |		classId := self context classIdOf: writeObjectClass.		self writeInteger: classId.		^ self writeContent: writeObject].	attributes := OrderedCollection new.	self addClassSpecifierAttributesTo: attributes for: writeObject.	self writeMapSize: attributes size.	attributes do: [:assoc |		self writePositiveFixNum: assoc key.		super writeObject: assoc value	].	self writeContent: writeObject</body><body package="Stomp-Core" selector="writeString:">writeString: aString	(self portableUtil isWideString: aString) ifTrue: [^self writeWideString: aString].	self writeByteString: aString</body><body package="Stomp-Core" selector="writeSymbol:">writeSymbol: aSymbol	(self portableUtil isWideSymbol: aSymbol) ifTrue: [^self writeWideSymbol: aSymbol].	self writeByteSymbol: aSymbol</body><body package="Stomp-Core" selector="writeValue:">writeValue: writeObject 	^ self		writeEmbeddedValue: writeObject		ifNotApplied: [self				writeObject: writeObject				ifNotApplied: [self writeStandardValue: writeObject]]</body><body package="Stomp-Core" selector="writeWideString:">writeWideString: aString	self writeArraySize: 2.	self writeTag: StompConstants wideString.	self writeRawBytes: (self portableUtil bytesFromString: aString)</body><body package="Stomp-Core" selector="writeWideSymbol:">writeWideSymbol: aSymbol	self writeArraySize: 2.	self writeTag: StompConstants wideSymbol.	self writeRawBytes: (self portableUtil bytesFromString: aSymbol)</body></methods><methods><class-id>StompWriter</class-id> <category>writing-attributes</category><body package="Stomp-Core" selector="addClassNameAttributeTo:for:">addClassNameAttributeTo: attributes for: writeObject	^attributes add: (StompConstants klassName -&gt; (self bytesFromIdentifierString: (self classNameOf: writeObject)))</body><body package="Stomp-Core" selector="addClassSpecifierAttributesTo:for:">addClassSpecifierAttributesTo: attributes for: writeObject 	| writeObjectClass |	writeObjectClass := writeObject class.	self addClassNameAttributeTo: attributes for: writeObject.	self context rememberClass: writeObjectClass.			(self context includesEnvironment: writeObjectClass environment)		ifTrue: [| envId |			envId := self context environmentIdOf: writeObjectClass environment.			self addEnvironmentIdAttributeTo: attributes id: envId]		ifFalse: [self addEnvironmentNameAttributeTo: attributes for: writeObject.			self context rememberEnvironment: writeObjectClass environment].</body><body package="Stomp-Core" selector="addEnvironmentIdAttributeTo:id:">addEnvironmentIdAttributeTo: attributes id: envId	^attributes add: (StompConstants environmentId -&gt; envId)</body><body package="Stomp-Core" selector="addEnvironmentNameAttributeTo:for:">addEnvironmentNameAttributeTo: attributes for: writeObject	| env |	self settings useEnvironment ifFalse: [^self].	(self portableUtil shouldWriteEnvironmentNameOf: writeObject) ifFalse: [^self].	env := self portableUtil environmentNameOf: writeObject.	^attributes add: (StompConstants environmentName -&gt; (self bytesFromIdentifierString: env))</body></methods><methods><class-id>StompWriter</class-id> <category>writing-helper</category><body package="Stomp-Core" selector="basicWriteInstVarsOf:">basicWriteInstVarsOf: writeObject 		| instVarNamesWithIndices |	instVarNamesWithIndices := self writtenInstVarNamesWithIndicesOf: writeObject.	self writeMapSize: 1.	self writeArraySize: instVarNamesWithIndices size.	instVarNamesWithIndices do: [:each | super writeObject: (self bytesFromIdentifierString: (each at: 1))].	self writeArraySize: instVarNamesWithIndices size.	instVarNamesWithIndices do: [:nmAndIndex |		| nm idx val | 		nm := nmAndIndex at: 1.		idx := nmAndIndex at: 2.		val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).		self writeObject: val	].</body><body package="Stomp-Core" selector="writeAll:">writeAll: collObject	| sz  |	sz := collObject size. 	self writeArraySize: sz.	collObject stompDo: [:each | self nextPut: each]</body><body package="Stomp-Core" selector="writeBitsOf:">writeBitsOf: writeObject	self writeRawBytes: writeObject stompBytes	</body><body package="Stomp-Core" selector="writeContent:">writeContent: writeObject	writeObject stompWriteContentTo: self</body><body package="Stomp-Core" selector="writeContent:tag:attributes:">writeContent: object tag: tag attributes: attribs	| sz |	sz := 2 + object stompValueContentSize. 	self writeArraySize: sz.	self writeTag: tag.	self writeMapSize: attribs size.	attribs do: [:assoc |		self writePositiveFixNum: assoc key.		super writeObject: assoc value	].	self writeContent: object</body><body package="Stomp-Core" selector="writeIndexFieldsOf:">writeIndexFieldsOf: writeObject	self writeAll: writeObject		</body><body package="Stomp-Core" selector="writeInstVarsOf:">writeInstVarsOf: writeObject 	|  cachedNamesWithIndices |	self settings suppressNilWrite ifTrue: [^self writeNotNilInstVarsOf: writeObject].		(cachedNamesWithIndices := self context instVarNamesWithIndicesOf: writeObject class) ifNotNil: [		^ self writeInstVarsOf: writeObject using: cachedNamesWithIndices	].		self basicWriteInstVarsOf: writeObject </body><body package="Stomp-Core" selector="writeInstVarsOf:using:">writeInstVarsOf: writeObject using: cachedNamesWithIndices	| classId |	classId := self context classIdOf: writeObject class.	classId ifNil: [^ self basicWriteInstVarsOf: writeObject].	self writeArraySize: cachedNamesWithIndices size + 1. 	self writeObject: classId.	cachedNamesWithIndices do: [:nmAndIndex |		| nm idx val | 		nm := nmAndIndex at: 1.		idx := nmAndIndex at: 2.		val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).		self writeObject: val	].</body><body package="Stomp-Core" selector="writeMixedFieldsOf:">writeMixedFieldsOf: writeObject 		| shouldWriteInstanceVariables |	writeObject class instSize = 0 ifTrue: [^self writeIndexFieldsOf: writeObject].		shouldWriteInstanceVariables := writeObject stompShouldWriteInstanceVariables.	shouldWriteInstanceVariables ifTrue: [		self writeObject: writeObject size.		self writeInstVarsOf: writeObject	].	self writeIndexFieldsOf: writeObject</body><body package="Stomp-Core" selector="writeNotNilInstVarsOf:">writeNotNilInstVarsOf: writeObject 	| instVarNamesWithIndices nameAndValues |	instVarNamesWithIndices := self writtenInstVarNamesWithIndicesOf: writeObject.	nameAndValues := OrderedCollection new.	instVarNamesWithIndices		do: [:nmAndIndex | 			| nm idx val | 			nm := nmAndIndex at: 1.			idx := nmAndIndex at: 2.			val := writeObject stompInstVarNamed: nm writtenAs: (writeObject instVarAt: idx).			val ifNotNil: [nameAndValues add: (Array with: (self bytesFromIdentifierString: (nm)) with: val)]].		self writeMapSize: 1.	self writeArraySize: nameAndValues size.	nameAndValues do: [:each | super writeObject: (each at: 1)].	self writeArraySize: nameAndValues size.	nameAndValues do: [:each | self writeObject: (each at: 2)].	</body><body package="Stomp-Core" selector="writeTag:">writeTag: tagInt	"tagInt should be 0-255"	self writeStream nextPut: (2r10100001).	self writeStream nextPut: tagInt</body><body package="Stomp-Core" selector="writeVersion">writeVersion	self writeStream nextPutAll: StompConstants header.	self writeStream nextPut: self defaultVersion "1-255"</body><body package="Stomp-Core" selector="writtenInstVarNamesWithIndicesOf:">writtenInstVarNamesWithIndicesOf: writeObject 	| writeObjectClass cachedNamesIndices instVarNames transientInstVarNames instVarIndices |	writeObjectClass := writeObject class.	(cachedNamesIndices := self context instVarNamesWithIndicesOf: writeObjectClass) ifNotNil: [^cachedNamesIndices].	instVarNames := writeObjectClass allInstVarNames asOrderedCollection.	transientInstVarNames := writeObject stompTransientInstVarNames.	transientInstVarNames := transientInstVarNames collect: [:each | each asString] .	transientInstVarNames do: [:each | instVarNames remove: each ifAbsent:[]].	instVarIndices := self portableUtil instVarIndicesOf: writeObjectClass from: instVarNames.	^ self context rememberInstVarNames: instVarNames indices: instVarIndices of: writeObjectClass.	</body></methods><methods><class-id>StompWriter</class-id> <category>stream-like</category><body package="Stomp-Core" selector="nextPut:">nextPut: anObject	self writeStompFrom: anObject</body><body package="Stomp-Core" selector="nextPutAll:">nextPutAll: aCollectionOfObject	aCollectionOfObject do: [:each | self nextPut: each]</body></methods><methods><class-id>StompWriter</class-id> <category>writing-custom</category><body package="Stomp-Core" selector="writePrimitiveValues:">writePrimitiveValues: anArray	"MessagePack types only"	"Never store object refs"	^super writeObject: anArray</body></methods><methods><class-id>StompWriter</class-id> <category>accessing</category><body package="Stomp-Core" selector="context">context	"Answer the value of context"	^ context ifNil: [context := StompWriteContext on: self]</body><body package="Stomp-Core" selector="context:">context: anObject	"Set the value of context"	context := anObject</body><body package="Stomp-Core" selector="portableUtil">portableUtil	^MpPortableUtil stomp</body></methods><methods><class-id>StompWriter</class-id> <category>constants</category><body package="Stomp-Core" selector="defaultVersion">defaultVersion	"Stomp version 1"	^1</body></methods><methods><class-id>StompWriter</class-id> <category>testing</category><body package="Stomp-Core" selector="putReferenceOf:ifExists:">putReferenceOf: anObject ifExists: aBlock	| refId |	refId := self context at: anObject ifAbsent: [].	refId notNil ifTrue: [^aBlock value: refId].		self rememberReferenceOf: anObject</body><body package="Stomp-Core" selector="supportsReferenceFor:">supportsReferenceFor: anObject	^anObject stompSupportsReference: self context	</body></methods><methods><class-id>StompWriter</class-id> <category>debugging</category><body package="Stomp-Core" selector="debugEncode:">debugEncode: bytes	|  encoded counterDic decoder |	encoded := self encode: bytes.	self context objectsDictionary.	counterDic := Dictionary new.	self context objectsDictionary keysAndValuesDo: [:k :v | counterDic at: v put: k].	counterDic inspect.	decoder := StompReader new.	decoder decode: encoded.	decoder context objectsDictionary inspect.	^encoded</body></methods><methods><class-id>StompMockVariableNewFailedClass</class-id> <category>accessing</category><body package="StompTest-Core" selector="att1">att1	^att1</body><body package="StompTest-Core" selector="att1:">att1: aValue	att1 := aValue</body><body package="StompTest-Core" selector="att2">att2	^att2</body><body package="StompTest-Core" selector="att2:">att2: aValue	att2 := aValue</body><body package="StompTest-Core" selector="att3Block">att3Block	^att3Block</body><body package="StompTest-Core" selector="att3Block:">att3Block: aValue	att3Block := aValue</body></methods><methods><class-id>StompMockVariableNewFailedClass</class-id> <category>testing-stomp</category><body package="StompTest-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables 	^ true</body></methods><methods><class-id>StompMockVariableNewFailedClass</class-id> <category>initializing-stomp</category><body package="StompTest-Core" selector="stompInitialize">stompInitialize	att3Block := [:a :b | a &lt; b].</body></methods><methods><class-id>StompMockVariableNewFailedClass class</class-id> <category>instance creation</category><body package="StompTest-Core" selector="new:">new: size	Error new signal: '#new: should not be called'</body></methods><methods><class-id>StompMockVariableNewFailedClass class</class-id> <category>for tests</category><body package="StompTest-Core" selector="prototype1">prototype1	"self prototype1"	| inst |	inst := self basicNew: 3.	1 to: 3 do: [:idx | inst at: idx put: idx printString].	inst att1: 1.	inst att2: 'TWO'.	inst att3Block: [:this | 'is block'].	^inst</body></methods><methods><class-id>StompMockVariableAlternativeClass class</class-id> <category>instance creation</category><body package="StompTest-Core" selector="new:">new: size	"new: is OK for me"	^self basicNew: size</body></methods><methods><class-id>StompCustomSerializationTestCase</class-id> <category>testing</category><body package="StompTest-Core" selector="testReadStompWriteValueAndStompReadValue">testReadStompWriteValueAndStompReadValue	"self debug: #testReadStompWriteValueAndStompReadValue"	| object1 object2 stomp1 docodedTuple className array stomp2 readArray inArray readObject1 readObject2 |	object1 := StompMockCustomWriteObject new.	object1 name: 'Masashi Umezawa'.	object1 email: 'mu@example.com'.		object2 := StompMockCustomWriteObject new.	object2 name: 'Shiho Umezawa'.	object2 email: 'su@example.com'.		stomp1 := object1 toStomp.	docodedTuple := MpDecoder decode: stomp1.	className := ((docodedTuple at: 2) at: StompConstants klassName) asString asSymbol.	self should: [className = #StompMockMementoArray].	array := Array with: object1 with: object2 with: (Array with: object1 with: object2 with: 3).	stomp2 := array toStomp.		readArray := Object fromStomp: stomp2.	inArray := readArray at: 3.	self should: [(readArray at: 1) = (inArray at: 1)].	self should: [(readArray at: 2) = (inArray at: 2)].	self shouldnt: [(readArray at: 3) = (Array with: object1 with: object2 with: 3)].		readObject1 := readArray at: 1.	self should: [readObject1 name = 'Masashi Umezawa'].		self should: [readObject1 email = 'mu@example.com'].	readObject2 := readArray at: 2.	self should: [readObject2 name = 'Shiho Umezawa'].		self should: [readObject2 email = 'su@example.com']</body><body package="StompTest-Core" selector="testSameStompWriteValueAndStompReadValue">testSameStompWriteValueAndStompReadValue	"self debug: #testSameStompWriteValueAndStompReadValue"	| obj1 array array2 |	obj1 := StompMockCustomWriteObject new name: 'AA'; email: 'aa@example.com'.	array := Array with: obj1 with: obj1.	array2 := Object fromStomp: array toStomp.	self should: [(array2 at: 1) = (array2 at: 2)].</body><body package="StompTest-Core" selector="testStompInitialize">testStompInitialize	"self debug: #testStompInitialize"	| obj readObject|	obj := StompMockObjectInitializingOnRead new.	obj instVar1: 'cache1'.	obj instVar2: 'cache2'.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = 'stomp initialized 1'].		self should: [readObject instVar2 = 'stomp initialized 2'].		self should: [readObject instVar3 = 3].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = 'cache1'].		self should: [obj instVar2 = 'cache2'].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].</body><body package="StompTest-Core" selector="testStompPrepareWrite">testStompPrepareWrite	"self debug: #testStompPrepareWrite"	| obj readObject|	obj := StompMockObjectPreparingOnWrite new.	obj instVar1: 1.	obj instVar2: 2.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = '1'].		self should: [readObject instVar2 = 4].		self should: [readObject instVar3 = 3].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = '1'].		self should: [obj instVar2 = 4].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].	</body><body package="StompTest-Core" selector="testStompTransientClassInstVarNames">testStompTransientClassInstVarNames	"self debug: #testStompTransientClassInstVarNames"	| obj encodedBytes readObject|	obj := StompMockObjectWithCache.	obj att1: 1.	obj att2: 2.	obj cache1: 'cache1'.	encodedBytes := StompWriter encode: obj.		obj att1: nil.	obj att2: nil.	obj cache1: nil.	readObject := StompReader decode: encodedBytes.	self should: [readObject att1 = 1].		self should: [readObject att2 = 2].		self should: [readObject cache1 = nil].				</body><body package="StompTest-Core" selector="testStompTransientInstVarNames">testStompTransientInstVarNames	"self debug: #testStompTransientInstVarNames"	| obj readObject|	obj := StompMockObjectWithCache new.	obj instVar1: '1'.	obj instVar2: '2'.	obj instVar3: 3.		obj instVar4: 4.	obj instVar5: 5.	readObject := StompReader decode: (StompWriter encode: obj).	self should: [readObject instVar1 = nil].		self should: [readObject instVar2 = nil].		self should: [readObject instVar3 = nil].		self should: [readObject instVar4 = 4].	self should: [readObject instVar5 = 5].		self should: [obj instVar1 = '1'].		self should: [obj instVar2 = '2'].		self should: [obj instVar3 = 3].		self should: [obj instVar4 = 4].	self should: [obj instVar5 = 5].</body></methods><methods><class-id>StompMockShapeChanger</class-id> <category>actions</category><body package="StompTest-Core" selector="loadAdditions">loadAdditions	self targetInstance instVar5: 'FIVE'.</body><body package="StompTest-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	"renamed"	varName = 'instVar2OLD' ifTrue: [^ self targetInstance instVar2: varValue ].		"removed"	"varName = 'instVar6' ifTrue: [^ self]."		^ super loadInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompMockMementoArray</class-id> <category>stomp-objectstream-reading</category><body package="StompTest-Core" selector="stompReadValue">stompReadValue	| inst |	inst := StompMockCustomWriteObject new.	inst name: (self at: 1).	inst email: (self at: 2).	^inst</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>factory</category><body package="Stomp-Core" selector="associationClass">associationClass	^ self classNamed: #Association</body><body package="Stomp-Core" selector="bagClass">bagClass	^ self classNamed: #Bag</body><body package="Stomp-Core" selector="byteStringClass">byteStringClass	^ self classNamed: #ByteString</body><body package="Stomp-Core" selector="byteSymbolClass">byteSymbolClass	^ self classNamed: #ByteSymbol</body><body package="Stomp-Core" selector="characterClass">characterClass	^ self classNamed: #Character</body><body package="Stomp-Core" selector="colorClass">colorClass	^ self classNamed: #Color</body><body package="Stomp-Core" selector="compactDictionaryClass">compactDictionaryClass	^ self classNamed: #CompactDictionary</body><body package="Stomp-Core" selector="compiledMethodClass">compiledMethodClass	^ self classNamed: #CompiledMethod</body><body package="Stomp-Core" selector="dateAndTimeClass">dateAndTimeClass	^ self classNamed: #DateAndTime</body><body package="Stomp-Core" selector="dateClass">dateClass	^ self classNamed: #Date</body><body package="Stomp-Core" selector="durationClass">durationClass	^ self classNamed: #Duration</body><body package="Stomp-Core" selector="fixedPointClass">fixedPointClass	^ self classNamed: #FixedPoint</body><body package="Stomp-Core" selector="fractionClass">fractionClass	^ self classNamed: #Fraction</body><body package="Stomp-Core" selector="identityDictionaryClass">identityDictionaryClass	^ self classNamed: #IdentityDictionary</body><body package="Stomp-Core" selector="identitySetClass">identitySetClass	^ self classNamed: #IdentitySet</body><body package="Stomp-Core" selector="intervalClass">intervalClass	^ self classNamed: #Interval</body><body package="Stomp-Core" selector="matrixClass">matrixClass	^ self classNamed: #Matrix</body><body package="Stomp-Core" selector="orderedCollectionClass">orderedCollectionClass	^ self classNamed: #OrderedCollection</body><body package="Stomp-Core" selector="orderedSetClass">orderedSetClass	^ self classNamed: #OrderedSet</body><body package="Stomp-Core" selector="pointClass">pointClass	^ self classNamed: #Point</body><body package="Stomp-Core" selector="rectangleClass">rectangleClass	^ self classNamed: #Rectangle</body><body package="Stomp-Core" selector="runArrayClass">runArrayClass	^ self classNamed: #RunArray</body><body package="Stomp-Core" selector="setClass">setClass	^ self classNamed: #Set</body><body package="Stomp-Core" selector="sortedCollectionClass">sortedCollectionClass	^ self classNamed: #SortedCollection</body><body package="Stomp-Core" selector="timeClass">timeClass	^ self classNamed: #Time</body><body package="Stomp-Core" selector="timestampClass">timestampClass	^ self classNamed: #Timestamp</body><body package="Stomp-Core" selector="uint16ArrayClass">uint16ArrayClass	^ self classNamed: #WordArray</body><body package="Stomp-Core" selector="uint32ArrayClass">uint32ArrayClass	^ self classNamed: #DwordArray</body><body package="Stomp-Core" selector="uuidClass">uuidClass	^ self classNamed: #UUID</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>constants</category><body package="Stomp-Core" selector="popularClassSelectors">popularClassSelectors	"Reserved popular classes - if you extend class map, the array should only be appended."	"^(self class organization listAtCategoryNamed: #factory) asSortedCollection."		^ #(#bagClass #compactDictionaryClass #characterClass #colorClass #dateAndTimeClass #dateClass #fractionClass #identityDictionaryClass #identitySetClass #intervalClass #orderedCollectionClass #pointClass #rectangleClass #setClass #sortedCollectionClass #matrixClass #durationClass #timeClass #timestampClass #runArrayClass #orderedSetClass #uuidClass #fixedPointClass #associationClass #compiledMethodClass #uint16ArrayClass #uint32ArrayClass).</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>accessing</category><body package="Stomp-Core" selector="classToCode">classToCode	"Answer the value of classToCode"	^ classToCode</body><body package="Stomp-Core" selector="classToCode:">classToCode: anObject	"Set the value of classToCode"	classToCode := anObject</body><body package="Stomp-Core" selector="codeToClass">codeToClass	"Answer the value of codeToClass"	^ codeToClass</body><body package="Stomp-Core" selector="codeToClass:">codeToClass: anObject	"Set the value of codeToClass"	codeToClass := anObject</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>private</category><body package="Stomp-Core" selector="classNamed:">classNamed: localClassName	^Smalltalk at: localClassName ifAbsent: []</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>actions</category><body package="Stomp-Core" selector="classAt:">classAt: code 	^self codeToClass at: code ifAbsent: [].	</body><body package="Stomp-Core" selector="codeAt:ifPresent:">codeAt: aClass ifPresent: aBlock	| code |	code := self classToCode at: aClass ifAbsent: [].	code ifNotNil: [aBlock value: code]</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>initialize-release</category><body package="Stomp-Core" selector="initialize">initialize	classToCode := IdentityDictionary new.	codeToClass := IdentityDictionary new.	self prepareMaps</body><body package="Stomp-Core" selector="prepareMaps">prepareMaps		self prepareCodeToClassMap: self codeToClass.	self prepareClassToCodeMap: self classToCode.</body></methods><methods><class-id>StompPopularClassMap</class-id> <category>preparing</category><body package="Stomp-Core" selector="prepareClassToCodeMap:">prepareClassToCodeMap: classToCodeMap	"By default, just create counter-map"	self codeToClass keysAndValuesDo: [:key :value |		classToCodeMap at: value put: key	]</body><body package="Stomp-Core" selector="prepareCodeToClassMap:">prepareCodeToClassMap: codeToClassMap	| selectors |	selectors := self popularClassSelectors.	1 to: selectors size do: [:idx | | kls |		kls := self perform: (selectors at: idx).		kls ifNotNil: [codeToClassMap at: idx put: kls].		]</body></methods><methods><class-id>StompPopularClassMap class</class-id> <category>class initialization</category><body package="Stomp-Core" selector="initialize">initialize	"self initialize"	self class = StompPopularClassMap ifTrue: [^self initializeAll].	default := nil	</body><body package="Stomp-Core" selector="initializeAll">initializeAll	"self initializeAll"	self allSubclasses do: [:each | each initialize]</body></methods><methods><class-id>StompPopularClassMap class</class-id> <category>accessing</category><body package="Stomp-Core" selector="default">default	"Answer the value of default"	^ default ifNil: [default := super new initialize]</body></methods><methods><class-id>StompMockPersonShapeChanger</class-id> <category>actions</category><body package="StompTest-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	varName = 'fullName' ifTrue: [^ self targetInstance name: varValue ].			^ super loadInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompShapeChangerTestCase</class-id> <category>fixtures</category><body package="StompTest-Core" selector="fixedClassOLDAnswerArray1">fixedClassOLDAnswerArray1	^  #[147 161 2 129 17 218 0 22 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 79 76 68 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 1 146 161 5 163 116 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 164 70 73 86 69]</body><body package="StompTest-Core" selector="fixedClassOLDAnswerArray2">fixedClassOLDAnswerArray2	 ^ #[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 171 105 110 115 116 86 97 114 50 79 76 68 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 54 149 1 146 161 5 170 114 101 110 97 109 101 100 84 119 111 203 64 10 102 102 102 102 102 102 194 146 161 4 167 65 68 68 69 68 45 54]</body><body package="StompTest-Core" selector="mockPersonAnswerArray1">mockPersonAnswerArray1	 ^  #[147 161 2 129 17 218 0 18 83 116 111 109 112 77 111 99 107 80 101 114 115 111 110 79 76 68 129 147 168 102 117 108 108 78 97 109 101 168 114 101 113 117 101 115 116 115 168 112 97 114 116 110 101 114 115 147 146 161 4 161 65 146 147 161 2 129 17 218 0 16 83 116 111 109 112 77 111 99 107 82 101 113 117 101 115 116 129 146 162 105 100 165 111 119 110 101 114 146 1 146 161 3 0 147 161 2 1 147 1 2 147 161 2 0 148 0 146 161 4 161 66 192 145 146 161 3 0 192]</body><body package="StompTest-Core" selector="renamedComplexReadAnswerArray1">renamedComplexReadAnswerArray1	 ^  #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1]</body><body package="StompTest-Core" selector="renamedComplexReadAnswerArray2">renamedComplexReadAnswerArray2	 ^  #[148 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1 146 161 4 164 104 101 114 101]</body><body package="StompTest-Core" selector="renamedComplexReadAnswerArray3">renamedComplexReadAnswerArray3	 ^ #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 146 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 146 1 3 147 161 2 0 147 0 11 33 146 161 3 1]</body><body package="StompTest-Core" selector="renamedComplexReadAnswerArray4">renamedComplexReadAnswerArray4	 ^  #[148 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 83 104 97 112 101 67 104 97 110 103 101 100 79 98 106 101 99 116 79 76 68 129 147 172 111 108 100 78 97 109 101 100 86 97 114 49 172 111 114 105 103 105 110 97 108 65 116 116 49 167 111 108 100 86 97 114 50 147 1 3 192 147 161 2 0 148 0 11 33 44 146 161 3 1 146 161 4 164 104 101 114 101]</body><body package="StompTest-Core" selector="renamedNewFailedAnswerArray1">renamedNewFailedAnswerArray1	 ^  #[147 147 161 2 129 17 218 0 30 83 116 111 109 112 77 111 99 107 70 105 120 101 100 65 108 116 101 114 110 97 116 105 118 101 67 108 97 115 115 129 147 164 97 116 116 49 164 97 116 116 50 169 97 116 116 51 66 108 111 99 107 147 1 2 192 147 161 2 0 148 0 3 4 192 146 161 3 1]</body><body package="StompTest-Core" selector="renamedReadFailedAnswerArray1">renamedReadFailedAnswerArray1	 ^ #[147 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 146 161 4 165 116 101 115 116 49 147 161 2 129 17 218 0 23 83 116 111 109 112 77 111 99 107 70 105 120 101 100 67 108 97 115 115 50 79 76 68 129 149 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 168 105 110 115 116 86 97 114 51 168 105 110 115 116 86 97 114 52 168 105 110 115 116 86 97 114 53 149 146 161 4 165 116 101 115 116 50 192 192 192 192 146 161 4 165 116 101 115 116 51 149 161 2 129 17 218 0 19 83 116 111 109 112 77 111 99 107 77 105 120 101 100 67 108 97 115 115 2 129 146 168 105 110 115 116 86 97 114 49 168 105 110 115 116 86 97 114 50 146 192 192 146 146 161 4 165 116 101 115 116 52 147 161 2 1 150 1 146 161 4 165 116 101 115 116 53 192 192 192 192 192]</body></methods><methods><class-id>StompShapeChangerTestCase</class-id> <category>testing</category><body package="StompTest-Core" selector="testBlockRenamedComplexShapeChangerRead">testBlockRenamedComplexShapeChangerRead	"self debug: #testBlockRenamedComplexShapeChangerRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray3.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD for: StompMockShapeChangedObject.		ctx registerShapeChangerRenameBy: [:target :oldName :value |			oldName = 'oldNamedVar1' ifTrue: [target renamedAtt1: value].		] initializeBy: [:target |			target addedAtt1: 22222.		] for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 22222].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 22222].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].</body><body package="StompTest-Core" selector="testBlockShapeChangedRead">testBlockShapeChangedRead	"self debug: #testBlockShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChangerRenameBy: [:target :oldName :value | 			oldName = 'instVar2OLD' ifTrue: [target instVar2: value].		] initializeBy: [:target | 			target instVar5: 'FIVE'		] for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].</body><body package="StompTest-Core" selector="testNewFailedRead">testNewFailedRead	"self debug: #testNewFailedRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedNewFailedAnswerArray1.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedNewFailedClass for: StompMockFixedAlternativeClass.	].	self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 class = StompMockFixedAlternativeClass].	self should: [obj1 att1 = 1].	self should: [obj1 att2 = 2].	self should: [obj1 att3Block notNil].	obj2 := arr at: 2.	self should: [obj2 class = StompMockFixedAlternativeClass].	self should: [obj2 att1 = 3].	self should: [obj2 att2 = 4].	self should: [obj2 att3Block notNil].	obj3 := arr at: 3.	self should: [obj3 = obj1].</body><body package="StompTest-Core" selector="testRenamedComplexRead">testRenamedComplexRead	"self debug: #testRenamedComplexRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray1.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 2].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 2].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].</body><body package="StompTest-Core" selector="testRenamedComplexReadFailed">testRenamedComplexReadFailed	"self debug: #testRenamedComplexReadFailed"	| bytes arr |	bytes := self renamedComplexReadAnswerArray2.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectFAILED for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 4].	self should: [arr = #(nil nil nil 'here')].</body><body package="StompTest-Core" selector="testRenamedComplexShapeChangerRead">testRenamedComplexShapeChangerRead	"self debug: #testRenamedComplexShapeChangerRead"	| bytes arr obj1 obj2 obj3 |	bytes := self renamedComplexReadAnswerArray3.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockShapeChangedObjectOLD shapeChanger: StompMockShapeChangerForRenamedComplexRead for: StompMockShapeChangedObject.	].		self should: [arr class = Array].	self should: [arr size = 3].	obj1 := arr at: 1.	self should: [obj1 renamedAtt1 = 1].	self should: [obj1 addedAtt1 = 22222].	self should: [obj1 originalAtt1 = 3].	obj2 := arr at: 2.	self should: [obj2 renamedAtt1 = 11].	self should: [obj2 addedAtt1 = 22222].	self should: [obj2 originalAtt1 = 33].	obj3 := arr at: 3.	self should: [obj3 = obj1].</body><body package="StompTest-Core" selector="testRenamedComplexShapeChangerReadFailed">testRenamedComplexShapeChangerReadFailed	"self debug: #testRenamedComplexShapeChangerReadFailed"	| bytes arr |	bytes := self renamedComplexReadAnswerArray4.	arr := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChanger: StompMockShapeChangerForRenamedComplexRead for: StompMockFixedClass.	].		self should: [arr class = Array].	self should: [arr size = 4].	self should: [arr = #(nil nil nil 'here')].</body><body package="StompTest-Core" selector="testRenamedRead">testRenamedRead	"self debug: #testRenamedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray1.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClassOLD for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #two.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].</body><body package="StompTest-Core" selector="testRenamedReadFailed">testRenamedReadFailed	"self debug: #testRenamedReadFailed"	| bytes inst |	bytes := self renamedReadFailedAnswerArray1.	"By default, unresolved class's instance will be nil"	inst := Object fromStomp: bytes.	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 isNil].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) isNil].	self should: [inst instVar5 isNil].		"Override the behavior by context"	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClass2OLD for: StompMockFixedClass2.	].	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 class = StompMockFixedClass2].	self should: [inst instVar2 instVar1= 'test2'].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) class = StompMockFixedClass2].	self should: [(inst instVar4 at: 2) instVar1 = 'test5'].	self should: [inst instVar5 isNil].		"Or you can use exception handling"	inst := [Object fromStomp: bytes ] on: StompClassNotFound do: [:ex |			ex resume: (ex className == #StompMockFixedClass2OLD ifTrue: [ StompMockFixedClass2] ifFalse: [ex unresolvedClass])].	self should: [inst class = StompMockFixedClass].	self should: [inst instVar1 = 'test1'].	self should: [inst instVar2 class = StompMockFixedClass2].	self should: [inst instVar2 instVar1= 'test2'].	self should: [inst instVar3 = 'test3'].	self should: [inst instVar4 class = StompMockMixedClass].	self should: [(inst instVar4 at: 1) = 'test4'].	self should: [(inst instVar4 at: 2) class = StompMockFixedClass2].	self should: [(inst instVar4 at: 2) instVar1 = 'test5'].	self should: [inst instVar5 isNil].</body><body package="StompTest-Core" selector="testRenamedShapeChangedRead">testRenamedShapeChangedRead	"self debug: #testRenamedShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockFixedClassOLD shapeChanger: StompMockShapeChanger for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].</body><body package="StompTest-Core" selector="testShapeChangedRead">testShapeChangedRead	"self debug: #testShapeChangedRead"	| bytes inst expected |	bytes := self fixedClassOLDAnswerArray2.	inst := Object fromStomp: bytes setting: [:ctx |		ctx registerShapeChanger: StompMockShapeChanger for: StompMockFixedClass.	].		expected := StompMockFixedClass new.	expected instVar1: 1.	expected instVar2: #renamedTwo.	expected instVar3: (StompPortableUtil default testFixturesClass double3dot3).	expected instVar4: false.	expected instVar5: 'FIVE'.		self should: [inst equals: expected].</body><body package="StompTest-Core" selector="testShapeChangedReadCircularReference">testShapeChangedReadCircularReference	"self debug: #testShapeChangedReadCircularReference"	| bytes obj |	bytes := self mockPersonAnswerArray1.	obj := Object fromStomp: bytes setting: [:ctx |		ctx registerClassOldName: #StompMockPersonOLD shapeChanger: StompMockPersonShapeChanger for: StompMockPerson.	]. 	self should: [obj class = StompMockPerson].	self should: [obj name = 'A'].	self should: [obj requests size = 2].	self should: [(obj requests detect: [:each | each id = 1]) owner = obj].	self should: [(obj requests detect: [:each | each id = 2]) owner name = 'B'].	self should: [(obj requests detect: [:each | each id = 2]) owner partners size = 1].	self should: [((obj requests detect: [:each | each id = 2]) owner partners at: 1) = obj].</body></methods><methods><class-id>StompVwFixtures class</class-id> <category>fixtures</category><body package="StompTest-VW-Core" selector="blueColor">blueColor	^ ColorValue blue</body><body package="StompTest-VW-Core" selector="double1234567890dot123456789">double1234567890dot123456789	^ 1234567890.123456789d</body><body package="StompTest-VW-Core" selector="double3dot3">double3dot3	^ 3.3d</body><body package="StompTest-VW-Core" selector="timestamp1">timestamp1	| timestamp tsClass |	tsClass := StompPortableUtil default popularClassMap timestampClass.	timestamp := tsClass fromDate: (StompPortableUtil default dateFromSeconds:  3330720000) andTime: (Time fromSeconds: 13506). 	^timestamp</body><body package="StompTest-VW-Core" selector="yellowColor">yellowColor	^ ColorValue yellow</body></methods><methods><class-id>StompVwPopularClassMap</class-id> <category>factory</category><body package="Stomp-VW-Core" selector="colorClass">colorClass	^ self classNamed: #ColorValue</body><body package="Stomp-VW-Core" selector="fixedPointClass">fixedPointClass	^ self classNamed: #ScaledDecimal</body><body package="Stomp-VW-Core" selector="matrixClass">matrixClass	^ self classNamed: #TwoDList</body></methods><methods><class-id>StompInvalidSerialization</class-id> <category>exceptionDescription</category><body package="Stomp-Core" selector="description">description	^ super description , ': ' , self className printString</body></methods><methods><class-id>StompReader</class-id> <category>reading-helper</category><body package="Stomp-Core" selector="readBitsOf:">readBitsOf: aClass	^aClass stompFromBytes: self basicReadObject.</body><body package="Stomp-Core" selector="readCollectionFieldsInto:">readCollectionFieldsInto: anInstance	| size |	size := self readSizeOfArray.	^ self readCollectionFieldsInto: anInstance sized: size</body><body package="Stomp-Core" selector="readCollectionFieldsInto:sized:">readCollectionFieldsInto: anInstance sized: size		anInstance class isVariable ifTrue: [^ self readIndexFieldsInto: anInstance sized: size].	1 to: size do:  [:idx | 		anInstance stompAdd: self readObject at: idx	].	^ anInstance</body><body package="Stomp-Core" selector="readIndexFieldsInto:sized:">readIndexFieldsInto: anInstance sized: size	1 to: size do:  [:idx | 		anInstance stompAt: idx put: self readObject	].	^ anInstance</body><body package="Stomp-Core" selector="readInstVarsInto:">readInstVarsInto: anInstance	| type arraySize varNames varIndices valueSize namesWithIndices values |	type := self readType. 	arraySize := ((type bitShift: -4) = 2r1001)		ifTrue: [type bitAnd: 16rF]		ifFalse: [type = 16rdc ifTrue: [MpPortableUtil default readUint16From: self readStream]].	arraySize ifNotNil: [^ self readInstVarsInto: anInstance fromInstVarReferenceArraySized: arraySize].		varNames := self basicReadObject collect: [:each | self identifierStringFromBytes: each].	varIndices := self portableUtil instVarIndicesOf: anInstance class from: varNames.	namesWithIndices := self context rememberInstVarNames: varNames indices: varIndices of: anInstance class.		valueSize := self readSizeOfArray.	values := OrderedCollection new: valueSize.	valueSize timesRepeat: [values add: (self readObject)].	^ self readInstVarsInto: anInstance namesWithIndices: namesWithIndices values: values</body><body package="Stomp-Core" selector="readInstanceContentAt:">readInstanceContentAt: classId	| actualClass |	actualClass := self context classAt: classId.	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentClassCoded:">readInstanceContentClassCoded: clsCode	| actualClass |	actualClass := self portableUtil popularClassMap classAt: clsCode.	actualClass ifNil: [actualClass :=  StompClassNotFound							signal: clsCode printString context: self context].	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentClassNamed:in:">readInstanceContentClassNamed: clsName in: envName	| actualClass |	actualClass := self context classNamed: clsName in: envName.	actualClass ifNil: [actualClass :=  StompClassNotFound							signal: clsName environment: envName context: self context].	self context rememberClass: actualClass. 	^self readInstanceContentOf: actualClass</body><body package="Stomp-Core" selector="readInstanceContentOf:">readInstanceContentOf: aClass	| inst newInst newKey |	inst := aClass stompCreateInstanceFrom: self.	newKey := self remember: inst.	aClass stompLoadContentsOnCreation ifFalse: [inst stompReadContentFrom: self].	self initializeInstance: inst.	newInst := inst stompReadValue.	newKey ifNotNil: [self remember: newInst at: newKey].	^ newInst</body><body package="Stomp-Core" selector="readSizeOfArray">readSizeOfArray	^ self readSizeOfArrayIfMatched: self readType</body><body package="Stomp-Core" selector="readSizeOfArrayIfMatched:">readSizeOfArrayIfMatched: type	((type bitShift: -4) = 2r1001) ifTrue: [^ type bitAnd: 16rF].	type = MpConstants array16		ifTrue: [^ MpPortableUtil default readUint16From: self readStream].	type = MpConstants array32		ifTrue: [^ MpPortableUtil default readUint32From: self readStream].	^-1</body><body package="Stomp-Core" selector="readUIntIfMatched:">readUIntIfMatched: type	(type &lt;= 16r7f) ifTrue: [^ self readPositiveFixNum: type].	type = MpConstants uint8		ifTrue: [^ self readUint8].	type = MpConstants uint16		ifTrue: [^ self readUint16].	type = MpConstants uint32		ifTrue: [^ self readUint32].	type = MpConstants uint64		ifTrue: [^ self readUint64].	^-1</body></methods><methods><class-id>StompReader</class-id> <category>private</category><body package="Stomp-Core" selector="basicReadObject">basicReadObject	"Never remembering"	^(MpDecoder on: self readStream) readObject</body><body package="Stomp-Core" selector="identifierStringFromBytes:">identifierStringFromBytes: byteArray 	byteArray ifNil: [^nil].	^ self settings supportsMultibyteIdentifiers		ifTrue: [self portableUtil stringFromBytes: byteArray]			ifFalse: [byteArray asString]</body><body package="Stomp-Core" selector="initializeInstance:">initializeInstance: instance 	| shapeChangerClass |	instance stompInitialize.	shapeChangerClass := self context shapeChangerFor: instance class.	shapeChangerClass		ifNotNil: [(shapeChangerClass on: instance) loadAdditions]</body><body package="Stomp-Core" selector="readIdentifierString">readIdentifierString	| type sz |	type := self readType.	(sz := type bitAnd: 2r01011111 &lt;= 31) ifTrue: [		^ self identifierStringFromBytes: (self readStream next: sz)	].	type = MpConstants raw16 ifTrue: [^ self identifierStringFromBytes: super readRaw16].	type = MpConstants raw32 ifTrue: [^ self identifierStringFromBytes: super readRaw32].	</body></methods><methods><class-id>StompReader</class-id> <category>factory</category><body package="Stomp-Core" selector="createDictionary:">createDictionary: size	| dic |	dic := super createDictionary: size.	self remember: dic.	^dic</body><body package="Stomp-Core" selector="settingsClass">settingsClass	^StompSettings</body></methods><methods><class-id>StompReader</class-id> <category>reading-attributes</category><body package="Stomp-Core" selector="readValueWithAttributes:">readValueWithAttributes: attribDict	| clsName envName |		clsName := self identifierStringFromBytes: (attribDict at: StompConstants klassName ifAbsent: []).	envName := self identifierStringFromBytes: (attribDict at: StompConstants environmentName ifAbsent: []).	envName		ifNil: 			[envName := self context						environmentNameAt: (attribDict at: StompConstants environmentId ifAbsent: [])]		ifNotNil: [self context rememberEnvironmentName: envName].	^ self readInstanceContentClassNamed: clsName in: envName</body></methods><methods><class-id>StompReader</class-id> <category>dispatching</category><body package="Stomp-Core" selector="readArraySized:">readArraySized: size 	size = 0 ifTrue: [| arr | self remember: (arr := self createArray: 0). ^arr].	^self readArraySized: size atFirstTyped: self readType</body><body package="Stomp-Core" selector="readArraySized:atFirst:">readArraySized: size atFirst: firstElem	| array |	array := self createArray: size.	self remember: array.	array at: 1 put: firstElem.	2 to: size do: [:idx | array at: idx put: self readObject].	^array</body><body package="Stomp-Core" selector="readArraySized:atFirstTyped:">readArraySized: size atFirstTyped: firstType	| array firstElem |	array := self createArray: size.	self remember: array.	firstElem := self readObjectOf: firstType.	array at: 1 put: firstElem.	2 to: size do: [:idx | array at: idx put: self readObject].	^array</body><body package="Stomp-Core" selector="readObjectOf:ifNotApplied:">readObjectOf: type ifNotApplied: aBlock	(type between: 16r90 and: 16r9f) ifTrue: [^ self readFixArray: type].	^super readObjectOf: type ifNotApplied: aBlock</body><body package="Stomp-Core" selector="readSmallArraySized:">readSmallArraySized: size 	| firstType |	size = 0 ifTrue: [| arr | self remember: (arr := self createArray: 0). ^arr].	firstType := self readType.	firstType = 16ra1 ifTrue: [| firstByte |			firstByte := self readStream next.			^ (StompConstants isTupleTag: firstByte)				ifTrue: [self readTupleBy: firstByte]				ifFalse: [self						readArraySized: size						atFirst: (ByteArray with: firstByte)]].	^self readArraySized: size atFirstTyped: firstType</body><body package="Stomp-Core" selector="readTupleBy:">readTupleBy: tag 	tag = StompConstants value ifTrue: [^self readValue].	tag = StompConstants reference ifTrue: [^self readReference].	tag = StompConstants byteString ifTrue: [^self readByteString].	tag = StompConstants byteSymbol ifTrue: [^self readByteSymbol].	tag = StompConstants wideString ifTrue: [^self readWideString].	tag = StompConstants wideSymbol ifTrue: [^self readWideString].	</body></methods><methods><class-id>StompReader</class-id> <category>reading-dispatched</category><body package="Stomp-Core" selector="readByteString">readByteString	^self basicReadObject asString</body><body package="Stomp-Core" selector="readByteSymbol">readByteSymbol	^self readByteString asSymbol</body><body package="Stomp-Core" selector="readReference">readReference	| refId |	refId := self readObject.	^(self context at: refId) yourself</body><body package="Stomp-Core" selector="readValue">readValue	| type attributesSize attribDict newInst |	type := self readType.	(type bitShift: -4) = 2r1000 ifFalse: [ | id |		id := self readObjectOf: type.		^ id &lt; 0 			ifTrue: [self readInstanceContentClassCoded: id negated]			ifFalse: [self readInstanceContentAt: id]	].	attributesSize := type bitAnd: 16rF.	attributesSize = 1 ifTrue: [ | key value |		key := self readPositiveFixNum: self readStream next.		value := self basicReadObject.		key = StompConstants klassName ifTrue: [^ self readInstanceContentClassNamed: (self identifierStringFromBytes: value) in: nil].	].	attribDict := Dictionary new: attributesSize.	1 to: attributesSize do: [:idx |		attribDict at: (self readPositiveFixNum: self readStream next) put: self basicReadObject	].	newInst :=  self readValueWithAttributes: attribDict.	^newInst	</body><body package="Stomp-Core" selector="readWideString">readWideString	^self portableUtil stringFromBytes: self basicReadObject</body><body package="Stomp-Core" selector="readWideSymbol">readWideSymbol	^self readWideString asSymbol</body></methods><methods><class-id>StompReader</class-id> <category>decoding</category><body package="Stomp-Core" selector="decodeFrom:">decodeFrom: aStream	| pos |	self readStream: aStream "binary".	pos := aStream position.	((self portableUtil nextAvailable: 2 from: aStream) = StompConstants header) ifTrue: [		self version: aStream next asInteger.	]. 	aStream position: pos. 	^self decode</body></methods><methods><class-id>StompReader</class-id> <category>accessing</category><body package="Stomp-Core" selector="context">context	"Answer the value of context"	^ context ifNil: [context := StompReadContext on: self]</body><body package="Stomp-Core" selector="context:">context: anObject	"Set the value of context"	context := anObject</body><body package="Stomp-Core" selector="portableUtil">portableUtil	^MpPortableUtil stomp</body><body package="Stomp-Core" selector="version">version	"Answer the value of version"	^ version</body><body package="Stomp-Core" selector="version:">version: anObject	"Set the value of version"	version := anObject</body></methods><methods><class-id>StompReader</class-id> <category>remembering</category><body package="Stomp-Core" selector="remember:">remember: anObject	^ self remember: anObject at: self context size	</body><body package="Stomp-Core" selector="remember:at:">remember: anObject at: key	anObject class = StompClassNotFound ifTrue: [		self context at: key put: nil.		^ key	].	(self supportsReferenceFor: anObject) ifFalse: [^nil]. 	self context at: key put: anObject.	^ key</body></methods><methods><class-id>StompReader</class-id> <category>reading-primitives</category><body package="Stomp-Core" selector="readFixArray:">readFixArray: firstByte	| size |	size := firstByte bitAnd: 16rF.	^ self readSmallArraySized: size</body><body package="Stomp-Core" selector="readFixRaw:">readFixRaw: type	| bytes |	bytes := super readFixRaw: type.	self remember: bytes.	^bytes</body><body package="Stomp-Core" selector="readRaw16">readRaw16	| bytes |	bytes := super readRaw16.	self remember: bytes.	^bytes</body><body package="Stomp-Core" selector="readRaw32">readRaw32	| bytes |	bytes := super readRaw32.	self remember: bytes.	^bytes</body></methods><methods><class-id>StompReader</class-id> <category>reading-custom</category><body package="Stomp-Core" selector="readPrimitiveValues">readPrimitiveValues	"Assuming &lt;= 15 fields"	| inst size |	size := self readStream next bitAnd: 16rF.	inst := self createArray: size.	size = 0 ifTrue: [^ inst].	^ super readArraySized: size</body></methods><methods><class-id>StompReader</class-id> <category>stream-like</category><body package="Stomp-Core" selector="next">next	^self readObject</body></methods><methods><class-id>StompReader</class-id> <category>reading-instance variables</category><body package="Stomp-Core" selector="readInstVarsInto:fromInstVarReferenceArraySized:">readInstVarsInto: anInstance fromInstVarReferenceArraySized: arraySize	| id  namesWithIndices values |	id :=  self basicReadObject.	namesWithIndices := self context instVarNamesWithIndicesAt: id.	values := Array new: namesWithIndices size.	1 to: values size do: [:idx | values at: idx put: self readObject].	self readInstVarsInto: anInstance namesWithIndices: namesWithIndices values: values</body><body package="Stomp-Core" selector="readInstVarsInto:namesWithIndices:values:">readInstVarsInto: anInstance namesWithIndices: varNamesWithIndices values: varValues	| shapeChangerClass |	shapeChangerClass := self context shapeChangerFor: anInstance class.	shapeChangerClass ifNil: [ 		varNamesWithIndices with: varValues do: [:nameWithIndex :value |			anInstance stompInstVarAt: (nameWithIndex at: 2) named: (nameWithIndex at: 1) put: value].	] ifNotNil: [ | shapeChanger |		shapeChanger := shapeChangerClass on: anInstance.		varNamesWithIndices with: varValues do: [:nameWithIndex :value | 			shapeChanger loadInstVarAt: (nameWithIndex at: 2) named: (nameWithIndex at: 1) put: value].	].			^anInstance</body></methods><methods><class-id>StompReader</class-id> <category>testing</category><body package="Stomp-Core" selector="supportsReferenceFor:">supportsReferenceFor: anObject	^anObject stompSupportsReference: self context	</body></methods><methods><class-id>StompMockObjectWithCache</class-id> <category>stomp-objectstream-writing</category><body package="StompTest-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	^#(instVar1 instVar2 instVar3)</body></methods><methods><class-id>StompMockObjectWithCache class</class-id> <category>accessing</category><body package="StompTest-Core" selector="att1">att1	"Answer the value of att1"	^ att1</body><body package="StompTest-Core" selector="att1:">att1: anObject	"Set the value of att1"	att1 := anObject</body><body package="StompTest-Core" selector="att2">att2	"Answer the value of att2"	^ att2</body><body package="StompTest-Core" selector="att2:">att2: anObject	"Set the value of att2"	att2 := anObject</body><body package="StompTest-Core" selector="cache1">cache1	"Answer the value of cache1"	^ cache1</body><body package="StompTest-Core" selector="cache1:">cache1: anObject	"Set the value of cache1"	cache1 := anObject</body></methods><methods><class-id>StompMockObjectWithCache class</class-id> <category>stomp-objectstream-writing</category><body package="StompTest-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	^super stompTransientInstVarNames, #(cache1)</body></methods><methods><class-id>StompBlockShapeChanger</class-id> <category>actions</category><body package="Stomp-Core" selector="loadAdditions">loadAdditions	loadAdditionsBlock ifNotNil: [loadAdditionsBlock value: self targetInstance]</body><body package="Stomp-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	loadInstVarsBlock ifNotNil: [loadInstVarsBlock value: self targetInstance value: varName value: varValue]. 		super loadInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompBlockShapeChanger</class-id> <category>accessing</category><body package="Stomp-Core" selector="loadAdditionsBlock">loadAdditionsBlock	"Answer the value of loadAdditionsBlock"	^ loadAdditionsBlock</body><body package="Stomp-Core" selector="loadAdditionsBlock:">loadAdditionsBlock: anObject	"Set the value of loadAdditionsBlock"	loadAdditionsBlock := anObject</body><body package="Stomp-Core" selector="loadInstVarsBlock">loadInstVarsBlock	"Answer the value of loadInstVarsBlock"	^ loadInstVarsBlock</body><body package="Stomp-Core" selector="loadInstVarsBlock:">loadInstVarsBlock: anObject	"Set the value of loadInstVarsBlock"	loadInstVarsBlock := anObject</body></methods><methods><class-id>StompBlockShapeChanger class</class-id> <category>instance creation</category><body package="Stomp-Core" selector="loadInstVarsBlock:loadAdditionsBlock:">loadInstVarsBlock: loadInstVarsBlock loadAdditionsBlock: loadAdditionsBlock	| inst |	inst := self new.	inst loadInstVarsBlock: loadInstVarsBlock.	inst loadAdditionsBlock: loadAdditionsBlock.	^ inst</body></methods><methods><class-id>StompReadWriteTestCase</class-id> <category>tests</category><body package="StompTest-Core" selector="testReadWriteText">testReadWriteText	"self debug: #testReadWriteText"	| bytes orig text |	orig := 'aaa' asText allBold.	bytes := orig toStomp.	text := Object fromStomp: bytes.		self should: [orig = text]</body></methods><methods><class-id>StompMockShapeChangerForRenamedComplexRead</class-id> <category>actions</category><body package="StompTest-Core" selector="loadAdditions">loadAdditions	self targetInstance addedAtt1: 22222</body><body package="StompTest-Core" selector="loadInstVarAt:named:put:">loadInstVarAt: varIndex named: varName put: varValue 	"renamed"	varName = 'oldNamedVar1' ifTrue: [^ self targetInstance renamedAtt1: varValue ].			^ super loadInstVarAt: varIndex named: varName put: varValue </body></methods><methods><class-id>StompMockMixedClass</class-id> <category>comparing</category><body package="StompTest-Core" selector="equals:">equals: other	self class = other class ifFalse: [^false].	instVar1 = other instVar1 ifFalse: [^false].	instVar2 = other instVar2 ifFalse: [^false].	^super = other</body></methods><methods><class-id>StompMockMixedClass</class-id> <category>accessing</category><body package="StompTest-Core" selector="instVar1">instVar1	"Answer the value of instVar1"	^ instVar1</body><body package="StompTest-Core" selector="instVar1:">instVar1: anObject	"Set the value of instVar1"	instVar1 := anObject</body><body package="StompTest-Core" selector="instVar2">instVar2	"Answer the value of instVar2"	^ instVar2</body><body package="StompTest-Core" selector="instVar2:">instVar2: anObject	"Set the value of instVar2"	instVar2 := anObject</body></methods><methods><class-id>StompMockMixedClass</class-id> <category>testing</category><body package="StompTest-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^true	</body></methods><methods><class-id>StompMockMixedClass class</class-id> <category>instance creation</category><body package="StompTest-Core" selector="new">new	^super new</body></methods><methods><class-id>MpPortableUtil class</class-id> <category>*stomp-core</category><body package="Stomp-Core" selector="stomp">stomp	^self default stompUtil</body></methods><methods><class-id>MpPortableUtil</class-id> <category>*Stomp-core-accessing</category><body package="Stomp-Core" selector="stompUtil">stompUtil	^ StompPortableUtil default</body></methods><methods><class-id>Core.DwordArray class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	| bytes |	bytes := rawBytes.	UninterpretedBytes isBigEndian ifFalse: [bytes fourByteEndiannessSwap].	^bytes changeClassTo: self</body></methods><methods><class-id>Core.DwordArray</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompBytes">stompBytes	| bytes |	bytes := self copy changeClassTo: ByteArray.	UninterpretedBytes isBigEndian ifFalse: [bytes fourByteEndiannessSwap].	^bytes</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rgbArray |	rgbArray := stompReader readPrimitiveValues.	^ StompPortableUtil default colorFromRgbArray: rgbArray	</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rgbArray |	rgbArray := Array with: self red asDouble  with: self green asDouble with: self blue asDouble.	stompWriter writePrimitiveValues: rgbArray.</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>*Stomp-VW-Core-reading</category><body package="Stomp-VW-Core" selector="stompAt:put:">stompAt: index put: aValue	^self stompAdd: aValue at: index</body></methods><methods><class-id>Core.UndefinedObject class</class-id> <category>*Stomp-Squeak-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rgbArray |	rgbArray := stompReader readPrimitiveValues.	^ StompPortableUtil default colorFromRgbArray: rgbArray	</body></methods><methods><class-id>UUID</class-id> <category>*Stomp-Squeak-Core-testing</category><body package="Stomp-VW-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-VW-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default timestampFromNanoseconds: stompReader readObject</body></methods><methods><class-id>Core.Timestamp</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default nanosecondsFromDateAndTime: self)</body></methods><methods><class-id>Core.Set</class-id> <category>*Stomp-VW-Core-reading</category><body package="Stomp-VW-Core" selector="stompAt:put:">stompAt: index put: aValue	^self stompAdd: aValue at: index</body></methods><methods><class-id>Core.WordArray class</class-id> <category>*Stomp-VW-Core-instance creation</category><body package="Stomp-VW-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	| bytes |	bytes := rawBytes.	UninterpretedBytes isBigEndian ifFalse: [bytes twoByteEndiannessSwap].	^bytes changeClassTo: self</body></methods><methods><class-id>Core.WordArray</class-id> <category>*Stomp-VW-Core-writing</category><body package="Stomp-VW-Core" selector="stompBytes">stompBytes	| bytes |	bytes := self copy changeClassTo: ByteArray.	UninterpretedBytes isBigEndian ifFalse: [bytes twoByteEndiannessSwap].	^bytes</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompAfterWrite">stompAfterWrite</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompAt:put:">stompAt: index put: aValue 	"override if you like"	self basicAt: index put: aValue</body><body package="Stomp-Core" selector="stompBasicReadContentFrom:">stompBasicReadContentFrom: stompReader 	| fieldsInfo |	self class isFixed ifTrue: [^ stompReader readInstVarsInto: self].		fieldsInfo := stompReader context fieldsInfo.	fieldsInfo isPureIndexFields ifTrue: [ ^ stompReader readIndexFieldsInto: self sized: fieldsInfo indexFieldSize].	fieldsInfo isMixedFields ifTrue: [		self stompShouldWriteInstanceVariables ifTrue: [stompReader readInstVarsInto: self].		stompReader readIndexFieldsInto: self sized: stompReader readSizeOfArray.	].		^self</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompBytes">stompBytes	"For bytes, words object"	"override"	^StompPortableUtil default bytesFrom: self </body><body package="Stomp-Core" selector="stompDo:">stompDo: aBlock	self class isFixed ifTrue:[		"I'm not an Collection - so just write myself"		^ aBlock value: self	].	self size = 0 ifTrue: [^ aBlock value: self].	1 to: self size do: [:idx |		aBlock value: (self at: idx)	].</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompInitialize">stompInitialize	"override if you like"	</body><body package="Stomp-Core" selector="stompInstVarAt:named:put:">stompInstVarAt: instVarIndex named: varName put: aValue 	instVarIndex = 0 ifTrue: [		^ StompPortableUtil default instVarNamed: varName put: aValue in: self	].	self instVarAt: instVarIndex put: aValue</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompInstVarNamed:writtenAs:">stompInstVarNamed: varName writtenAs: writtenValue	"override"	^ writtenValue</body><body package="Stomp-Core" selector="stompPrepareWrite">stompPrepareWrite</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompReadContentFrom:">stompReadContentFrom: stompReader 	"override"	^self stompBasicReadContentFrom: stompReader 	</body><body package="Stomp-Core" selector="stompReadValue">stompReadValue	"override if you like"	^self</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^true	</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	"override"	^true	</body></methods><methods><class-id>Core.Object</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	"override"	^#()</body><body package="Stomp-Core" selector="stompValueContentSize">stompValueContentSize	"For Mixed class which would like to write instance variables"	((self stompShouldWriteInstanceVariables			and: [self class isVariable])			and: [self class instSize &gt; 0])		ifTrue: [^ 3].	^ 1</body><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter 	"Override as you wish"	"Provides basic dispatch to stompWriter"	| cls |	cls := self class.	cls isBits ifTrue: [^ stompWriter writeBitsOf: self].	cls isVariable ifTrue: [^ stompWriter writeMixedFieldsOf: self].	^ stompWriter writeInstVarsOf: self</body><body package="Stomp-Core" selector="stompWriteValue">stompWriteValue	^self</body><body package="Stomp-Core" selector="toStomp">toStomp	^ StompWriter encode: self</body></methods><methods><class-id>Core.String</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Metaclass</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstance">stompCreateInstance	^ StompPortableUtil default soleInstanceOf: self</body></methods><methods><class-id>Core.Collection class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateCollectionInstanceFrom:">stompCreateCollectionInstanceFrom: stompReader	^self stompCreateMixedInstanceFrom: stompReader</body><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| cls |	stompReader context clearFieldsInfo.	cls := self.	cls isBits ifTrue: [^ self stompCreateBitsInstanceFrom: stompReader].	^ self stompCreateCollectionInstanceFrom: stompReader				</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompAdd:at:">stompAdd: elem at: idx	"override"	self add: elem</body><body package="Stomp-Core" selector="stompDo:">stompDo: aBlock	"override"	self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompReadContentFrom:">stompReadContentFrom: stompReader 	| fieldsInfo |	fieldsInfo := stompReader context fieldsInfo.	fieldsInfo isNil ifTrue: [^self].	fieldsInfo isPureIndexFields ifTrue: [ ^ stompReader readCollectionFieldsInto: self sized: fieldsInfo indexFieldSize].	fieldsInfo isMixedFields ifTrue: [		self stompShouldWriteInstanceVariables ifTrue: [stompReader readInstVarsInto: self].		stompReader readCollectionFieldsInto: self.	].		^self</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	"override"	"Usually Collection's inst vars are not needed for serialization"	^false	</body></methods><methods><class-id>Core.Collection</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter 	"Override as you wish"	"Provides basic dispatch to stompWriter"	| cls |	cls := self class.	cls isBits ifTrue: [^ stompWriter writeBitsOf: self].	^ stompWriter writeMixedFieldsOf: self</body></methods><methods><class-id>Core.Duration class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default durationFromNanoseconds: stompReader readObject</body></methods><methods><class-id>Core.Duration</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default nanosecondsFromDuration: self)</body></methods><methods><class-id>Core.Character class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default characterFromUnicode: stompReader readObject</body></methods><methods><class-id>Core.Character</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: (StompPortableUtil default unicodeFromCharacter: self)</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompLoadContentsOnCreation">stompLoadContentsOnCreation	"override"	self isBits ifTrue: [^true]. 	^ self class includesSelector: #stompCreateInstanceFrom: "Typically"	</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompTransientInstVarNames">stompTransientInstVarNames	^Object class allInstVarNames</body></methods><methods><class-id>Core.Symbol class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ (super stompCreateInstanceFrom: stompReader) asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>*Stomp-Core</category><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Number</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false	</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="fromStomp:">fromStomp: bytes	^ StompReader decode: bytes</body><body package="Stomp-Core" selector="fromStomp:setting:">fromStomp: bytes setting: aBlock	| context reader |	reader := StompReader new.	context := reader context.	aBlock value: context.	^reader decode: bytes.</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation-helper</category><body package="Stomp-Core" selector="stompCreateBitsInstanceFrom:">stompCreateBitsInstanceFrom: stompReader	^stompReader readBitsOf: self</body><body package="Stomp-Core" selector="stompCreateFixedInstanceFrom:">stompCreateFixedInstanceFrom: stompReader	^self stompCreateInstance</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstance">stompCreateInstance	^[self new]		on: Error		do: [:ex | 			| alterClass | 			alterClass := StompNewFailed signal: self name.			alterClass isNil				ifTrue: [self basicNew]				ifFalse: [alterClass basicNew]]</body><body package="Stomp-Core" selector="stompCreateInstance:">stompCreateInstance: size	^ [self new: size]		on: Error		do: [:ex | 			| alterClass | 			alterClass := StompNewFailed signal: self name.			alterClass isNil				ifTrue: [[self basicNew: size] on: Error do: [self stompCreateInstance]]				ifFalse: [alterClass basicNew: size]]</body><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| cls |	stompReader context clearFieldsInfo.	cls := self.	cls isBits ifTrue: [^ self stompCreateBitsInstanceFrom: stompReader].	cls isVariable		ifTrue: [^ self stompCreateMixedInstanceFrom: stompReader].			^ self stompCreateFixedInstanceFrom: stompReader</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation-helper</category><body package="Stomp-Core" selector="stompCreateMixedInstanceFrom:">stompCreateMixedInstanceFrom: stompReader	| type size indexFieldSize  |	type := stompReader readType. 	size := stompReader readSizeOfArrayIfMatched: type.	size = 0 ifTrue: [^ self stompCreateInstance].	size &gt;= 1 ifTrue: [		stompReader context fieldsInfo: (StompFieldsInfo pureIndexFieldsSized: size).		^ self stompCreateInstance: size. 	].	"Otherwise, mixed fields"	indexFieldSize := stompReader readUIntIfMatched: type.	stompReader context fieldsInfo: (StompFieldsInfo mixedFields).	^ self stompCreateInstance: indexFieldSize</body></methods><methods><class-id>Core.Behavior</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompFromBytes:">stompFromBytes: rawBytes	"For bits object"	"override - if nessesary"	^StompPortableUtil default bytes: rawBytes intoOf: self. 	</body></methods><methods><class-id>Core.Boolean</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*Stomp-Core</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false	</body></methods><methods><class-id>Core.Time class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^self fromSeconds: stompReader readObject</body></methods><methods><class-id>Core.Time</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Time</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: self asSeconds</body></methods><methods><class-id>Core.Point class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rectArray |	rectArray := stompReader readPrimitiveValues.	^ (rectArray at: 1) @ (rectArray at: 2)</body></methods><methods><class-id>Core.Point</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rectArray |	rectArray := Array with: self x with: self y.	stompWriter writePrimitiveValues: rectArray</body></methods><methods><class-id>Kernel.BlockClosure class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	StompInvalidDeserialization signal: stompReader readObject.	^nil</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	StompInvalidSerialization signal: self class name.	stompWriter writeObject: self printString</body></methods><methods><class-id>Core.Text</class-id> <category>*Stomp-Core-reading</category><body package="Stomp-Core" selector="stompAdd:at:">stompAdd: elem at: idx	self at: idx put: elem</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| rectArray |	rectArray := stompReader readPrimitiveValues.	^ (rectArray at: 1) @ (rectArray at: 2) corner: (rectArray at: 3) @ (rectArray at: 4)</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	| rectArray |	rectArray := Array with: self origin x with: self origin y with: self corner x with: self corner y.	stompWriter writePrimitiveValues: rectArray</body></methods><methods><class-id>Core.IdentityDictionary class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| dic inst |	dic := stompReader readObject.	inst := self new.	dic keysAndValuesDo: [:k :v | inst at: k put: v].		^ inst</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeMap: self.		</body></methods><methods><class-id>Core.Date class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	^ StompPortableUtil default dateFromSeconds: stompReader readObject</body></methods><methods><class-id>Core.Date</class-id> <category>*Stomp-Core-testing</category><body package="Stomp-Core" selector="stompShouldWriteInstanceVariables">stompShouldWriteInstanceVariables	^false</body><body package="Stomp-Core" selector="stompSupportsReference:">stompSupportsReference: stompContext	^false</body></methods><methods><class-id>Core.Date</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writeObject: self asSeconds</body></methods><methods><class-id>Core.RunArray class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| fraArray |	fraArray := stompReader readPrimitiveValues.	^self runs: (fraArray at: 1) values: (fraArray at: 2)</body></methods><methods><class-id>Core.RunArray</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: self runs with: self values)</body></methods><methods><class-id>Core.Interval class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| intervalArray |	intervalArray := stompReader readPrimitiveValues.	^self from: (intervalArray at: 1) to: (intervalArray at: 2) by: (intervalArray at: 3)</body></methods><methods><class-id>Core.Interval</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: start with: stop with: step)</body></methods><methods><class-id>Core.Fraction class</class-id> <category>*Stomp-Core-instance creation</category><body package="Stomp-Core" selector="stompCreateInstanceFrom:">stompCreateInstanceFrom: stompReader	| fraArray |	fraArray := stompReader readPrimitiveValues.	^self numerator: (fraArray at: 1) denominator: (fraArray at: 2)</body></methods><methods><class-id>Core.Fraction</class-id> <category>*Stomp-Core-writing</category><body package="Stomp-Core" selector="stompWriteContentTo:">stompWriteContentTo: stompWriter	stompWriter writePrimitiveValues: (Array with: self numerator with: self denominator)</body></methods><initialize><class-id>StompPortableUtil</class-id></initialize><initialize><class-id>StompVwPortableUtil</class-id></initialize><initialize><class-id>StompWarning</class-id></initialize><initialize><class-id>StompConstants</class-id></initialize><initialize><class-id>StompPopularClassMap</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>MpDecoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>DwordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>UUID</name><environment>Smalltalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UUID</category><attributes><package>UUID</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>MpEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writeStream typeMapper settings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>totalNanoseconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>MpPortableUtil</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MpSettings</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MessagePack-Core</category><attributes><package>MessagePack-Core</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>